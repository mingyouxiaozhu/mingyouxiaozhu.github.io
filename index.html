<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="enjoy life ,enjoy coding">
<meta property="og:type" content="website">
<meta property="og:title" content="mingyouxiaozhu&#39;s blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="mingyouxiaozhu&#39;s blog">
<meta property="og:description" content="enjoy life ,enjoy coding">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="mingyouxiaozhu">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>mingyouxiaozhu's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">mingyouxiaozhu's blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">mingyouxiaozhu</p>
  <div class="site-description" itemprop="description">enjoy life ,enjoy coding</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/06/LevelDB%E4%B9%8BMemTable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mingyouxiaozhu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingyouxiaozhu's blog">
      <meta itemprop="description" content="enjoy life ,enjoy coding">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | mingyouxiaozhu's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/06/LevelDB%E4%B9%8BMemTable/" class="post-title-link" itemprop="url">LevelDB之MemTable</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-06 10:21:15 / 修改时间：16:56:32" itemprop="dateCreated datePublished" datetime="2023-09-06T10:21:15+08:00">2023-09-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​	在 LevelDB 中，写完 WAL 日志以后，就可以将数据写入到 MemTable 了。MemTable 是 LSM-Tree必不可缺的一个组件，主要作用如下：</p>
<ol>
<li>写入的时候作为随机写转换为顺序写的buffer也是对数据进行排序的处理器</li>
<li>读取的时候作为热点数据（刚写入的数据）的cache，加快读取速度</li>
<li>SSTable 的数据来源，初始的SSTable都是一个MemTable的持久化</li>
</ol>
<p>在具体的使用中，MemTable 需要在内存中开辟堆空间，所以需要内存管理。客户端一般写入MemTable后就可以返回成功。</p>
<p>本文将针对MemTable 在 LevelDB 中的实现做一个简单的介绍，一起将客户端的写入过程也做了个介绍，会涉及到LevelDB如何控制并发等。</p>
<p>MemTable的实现在<code>db/memtable.h</code>和<code>db/memtable.cc</code>。内存管理的是实现是在<code>util/arena.h</code></p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>MemTable 数据结构就是前面提到过的SkipList。LevelDB 是将key和value组合在一起成为一个SkipList中的Node，所以MemTable中还包含了一个比较器。这里对SkipList不再做具体的介绍，如果想深入了解，可以看下我前面写的SkipList原理和Java实现。</p>
<p>在<code>db/memtable.h</code>中的具体实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTable</span> &#123;</span></span><br><span class="line"> public:</span><br><span class="line">  <span class="comment">// MemTables are reference counted.  The initial reference count</span></span><br><span class="line">  <span class="comment">// is zero and the caller must call Ref() at least once.</span></span><br><span class="line">  explicit <span class="title function_">MemTable</span><span class="params">(<span class="type">const</span> InternalKeyComparator&amp; comparator)</span>;</span><br><span class="line"></span><br><span class="line">  MemTable(<span class="type">const</span> MemTable&amp;) = delete;</span><br><span class="line">  MemTable&amp; operator=(<span class="type">const</span> MemTable&amp;) = delete;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Increase reference count.</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Ref</span><span class="params">()</span> &#123; ++refs_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop reference count.  Delete if no more references exist.</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Unref</span><span class="params">()</span> &#123;</span><br><span class="line">    --refs_;</span><br><span class="line">    assert(refs_ &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (refs_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      delete this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an estimate of the number of bytes of data in use by this</span></span><br><span class="line">  <span class="comment">// data structure. It is safe to call when MemTable is being modified.</span></span><br><span class="line">  <span class="type">size_t</span> <span class="title function_">ApproximateMemoryUsage</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an iterator that yields the contents of the memtable.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The caller must ensure that the underlying MemTable remains live</span></span><br><span class="line">  <span class="comment">// while the returned iterator is live.  The keys returned by this</span></span><br><span class="line">  <span class="comment">// iterator are internal keys encoded by AppendInternalKey in the</span></span><br><span class="line">  <span class="comment">// db/format.&#123;h,cc&#125; module.</span></span><br><span class="line">  Iterator* <span class="title function_">NewIterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add an entry into memtable that maps key to value at the</span></span><br><span class="line">  <span class="comment">// specified sequence number and with the specified type.</span></span><br><span class="line">  <span class="comment">// Typically value will be empty if type==kTypeDeletion.</span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">Add</span><span class="params">(SequenceNumber seq, ValueType type, <span class="type">const</span> Slice&amp; key,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> Slice&amp; value)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If memtable contains a value for key, store it in *value and return true.</span></span><br><span class="line">  <span class="comment">// If memtable contains a deletion for key, store a NotFound() error</span></span><br><span class="line">  <span class="comment">// in *status and return true.</span></span><br><span class="line">  <span class="comment">// Else, return false.</span></span><br><span class="line">  <span class="type">bool</span> <span class="title function_">Get</span><span class="params">(<span class="type">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s)</span>;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  friend <span class="class"><span class="keyword">class</span> <span class="title">MemTableIterator</span>;</span></span><br><span class="line">  friend <span class="class"><span class="keyword">class</span> <span class="title">MemTableBackwardIterator</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">KeyComparator</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> InternalKeyComparator comparator;</span><br><span class="line">    explicit <span class="title function_">KeyComparator</span><span class="params">(<span class="type">const</span> InternalKeyComparator&amp; c)</span> : <span class="title function_">comparator</span><span class="params">(c)</span> &#123;&#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b)</span> <span class="type">const</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> SkipList&lt;<span class="type">const</span> <span class="type">char</span>*, KeyComparator&gt; Table;</span><br><span class="line"></span><br><span class="line">  ~MemTable();  <span class="comment">// Private since only Unref() should be used to delete it</span></span><br><span class="line"></span><br><span class="line">  KeyComparator comparator_;</span><br><span class="line">  <span class="type">int</span> refs_;</span><br><span class="line">  Arena arena_;</span><br><span class="line">  Table table_;</span><br><span class="line">  <span class="type">void</span> <span class="title function_">PrintBuffer</span><span class="params">(<span class="type">char</span>* buf, <span class="type">size_t</span> i)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的实现中可以看到，MemTable 拒绝复制当前内部的数据，或者说拒绝使用拷贝构造函数和赋值来拷贝当前的数据。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MemTable(<span class="type">const</span> MemTable&amp;) = delete;</span><br><span class="line">MemTable&amp; operator=(<span class="type">const</span> MemTable&amp;) = delete;</span><br><span class="line">这两个方法的代码指的是禁止了MemTable的复制，也就是说一个MemTable不能通过拷贝构造函数构创建新对象的方式复制当前MemTable对象。也不能使用赋值运算符来创建一个新的对象并且指向当前的对象，赋值运算符也是会拷贝数据的。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>能够创建一个MemTable的方式只有使用传入一个<code>InternalKeyComparator</code>。也不能够复制当前MemTable中的数据。</p>
<p>MemTable中还有一个Ref，这个和gc中的引用是一个意思，如果这个refs中的数据没有到0，说明有人还在使用这个MemTable，那么就不能进行内存释放。</p>
<p><code>ApproximateMemoryUsage</code>当前已经使用的内存，这个命名是说这个是一个大概的值，我觉得挺神奇的，后面看下为什么是大概的值，是否可能会有并发访问结果不一样的情况。</p>
<p><code>NewIterator</code>创建一个迭代器</p>
<p>提供的读写接口就两个，一个是Get 一个是Add：</p>
<ul>
<li>Add 返回值是void 入参分别为<ul>
<li>SequenceNumber seq 当前写入的sequence</li>
<li>ValueType type &#x2F;&#x2F; 类型，该类型只有两种，一个是删除，一个是写入</li>
<li>const Slice&amp; key &#x2F;&#x2F; 写入的key</li>
<li>const Slice&amp; value)&#x2F;&#x2F;写入的Value</li>
</ul>
</li>
<li>Get 返回值是true 入参分别为：<ul>
<li>const LookupKey&amp; key &#x2F;&#x2F; 查询的Key值</li>
<li>std::string* value 如果有数据就会写在value里面，也就是如果返回为true，那么值就在value里面</li>
<li>Status* s 如果查询的值已经被删除，那么status会有一个error但是函数会返回true</li>
</ul>
</li>
</ul>
<p>私有域中主要包含了两个迭代器，Key的比较器，内存分配的Arena 和Table，这个Table就是SkipList。在析构函数里说的很清楚的就是只有在Unref里面可以调用，也就是当refs_的值小于等于0 的时候就可以释放当前的内存。</p>
<h2 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h2><p>add 是将当前的值写入到MemTable中，为了更好理解里面的并发控制和sequence，直接看db的Write操作，是在<code>db/db_impl.cc</code>中的DBImpl::Write中，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DBImpl::Write</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> &#123;</span><br><span class="line">  Writer <span class="title function_">w</span><span class="params">(&amp;mutex_)</span>; <span class="comment">// 每次写入都会封装为一个Writer，这个在前面的Log中有了解，注意的是，Writer中传入了互斥锁</span></span><br><span class="line">  w.batch = updates; <span class="comment">// 写入操作在Put的是已经封装为了WriteBatch</span></span><br><span class="line">  w.sync = options.sync; <span class="comment">// 判断当前是否同步刷盘，也是Log中的操作</span></span><br><span class="line">  w.done = <span class="literal">false</span>; <span class="comment">// 当前写入状态初始为false</span></span><br><span class="line">	<span class="comment">// 锁a</span></span><br><span class="line">  MutexLock <span class="title function_">l</span><span class="params">(&amp;mutex_)</span>; <span class="comment">// 首先根据信号量初始化锁</span></span><br><span class="line">  writers_.push_back(&amp;w); <span class="comment">// 将写入操作放入一个writers队列中，注意因为有锁，所以同一时间只会有一个线程进入到writers中</span></span><br><span class="line">  <span class="keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.front()) &#123;</span><br><span class="line">    w.cv.Wait(); <span class="comment">// 需要注意的是，在Wait阶段是会释放锁的</span></span><br><span class="line">  &#125; <span class="comment">// 使用队头的writer作为本次写入的writer</span></span><br><span class="line">  <span class="keyword">if</span> (w.done) &#123; <span class="comment">// 如果本次的写入已经被完成，则直接返回写入的状态</span></span><br><span class="line">    <span class="keyword">return</span> w.status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// May temporarily unlock and wait.</span></span><br><span class="line">  Status status = MakeRoomForWrite(updates == nullptr); <span class="comment">// 创建空间用于写入磁盘或者memTable</span></span><br><span class="line">  <span class="type">uint64_t</span> last_sequence = versions_-&gt;LastSequence(); <span class="comment">// 从当前的version中获取到最后使用的sequence</span></span><br><span class="line">  Writer* last_writer = &amp;w; <span class="comment">//本次写入的writer赋值给last_writer,注意为什么这里明明&amp;w是队头却是lastwriter，是因为在后面的BuildBatchGroup方法中，会将本次批量写入的最后一个writer赋值给他</span></span><br><span class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; updates != nullptr) &#123;  <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">    WriteBatch* write_batch = BuildBatchGroup(&amp;last_writer); <span class="comment">// 将当前队列中所有的writer里面的数据合并为一次写入</span></span><br><span class="line">    WriteBatchInternal::SetSequence(write_batch, last_sequence + <span class="number">1</span>);<span class="comment">// 设置本次批量写入的sequence，sequence每次写入都是递增的，保证了写入的顺序，也能够进行读取的MVVC</span></span><br><span class="line">    last_sequence += WriteBatchInternal::Count(write_batch); <span class="comment">// 更新当前的lastSequence，write_batch 中包含了当前数据的大大小</span></span><br><span class="line">    <span class="comment">// Add to log and apply to memtable.  We can release the lock</span></span><br><span class="line">    <span class="comment">// during this phase since &amp;w is currently responsible for logging</span></span><br><span class="line">    <span class="comment">// and protects against concurrent loggers and concurrent writes</span></span><br><span class="line">    <span class="comment">// into mem_.</span></span><br><span class="line">    &#123;</span><br><span class="line">      mutex_.Unlock(); <span class="comment">// 释放队列锁，此时可以继续写入writers队列了。但是由于当前的writer 没有从队头移除，所以此时仍然等待在 w.cv.Wait();中</span></span><br><span class="line">      status = log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch)); <span class="comment">// 写入Log文件</span></span><br><span class="line">      <span class="type">bool</span> sync_error = <span class="literal">false</span>; </span><br><span class="line">      <span class="keyword">if</span> (status.ok() &amp;&amp; options.sync) &#123; <span class="comment">// 写入成功，是否同步刷盘</span></span><br><span class="line">        status = logfile_-&gt;Sync();</span><br><span class="line">        <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">          sync_error = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">        status = WriteBatchInternal::InsertInto(write_batch, mem_); <span class="comment">// 此处写入mem</span></span><br><span class="line">      &#125;</span><br><span class="line">      mutex_.Lock(); <span class="comment">// 再次获取到锁，暂停线程写入writers，注意的是，这个锁的释放是等到本次线程退出方法，调用MutexLock的析构函数达到释放锁的目的</span></span><br><span class="line">      <span class="keyword">if</span> (sync_error) &#123;</span><br><span class="line">        <span class="comment">// The state of the log file is indeterminate: the log record we</span></span><br><span class="line">        <span class="comment">// just added may or may not show up when the DB is re-opened.</span></span><br><span class="line">        <span class="comment">// So we force the DB into a mode where all future writes fail.</span></span><br><span class="line">        RecordBackgroundError(status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (write_batch == tmp_batch_) tmp_batch_-&gt;Clear(); <span class="comment">// 清理tmp_batch</span></span><br><span class="line">    versions_-&gt;SetLastSequence(last_sequence);<span class="comment">// 设置sequence 到version中</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Writer* ready = writers_.front();</span><br><span class="line">    writers_.pop_front();</span><br><span class="line">    <span class="keyword">if</span> (ready != &amp;w) &#123;</span><br><span class="line">      ready-&gt;status = status;</span><br><span class="line">      ready-&gt;done = <span class="literal">true</span>;</span><br><span class="line">      ready-&gt;cv.Signal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ready == last_writer) <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="comment">// 依次唤醒本次写入的后续writer，此时会从上面的while中继续调用，如果是头节点，而且已经被写入则直接返回，否则就继续执行上面的代码,该循环一直到本次写入的最后一个writer位置</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Notify new head of write queue</span></span><br><span class="line">  <span class="keyword">if</span> (!writers_.empty()) &#123; <span class="comment">// 唤醒下一次调用</span></span><br><span class="line">    writers_.front()-&gt;cv.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算得上逐行解释了上面的代码。接下来看下如何使用一个互斥锁实现兼顾多线程顺序写入和效率的。</p>
<h3 id="Add中的锁"><a href="#Add中的锁" class="headerlink" title="Add中的锁"></a>Add中的锁</h3><p>先来看最开始的while循环中的cv.Wait()方法，在<code>port/port_stdcxx.h</code>中，实现为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Wait() &#123;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lock(mu_-&gt;mu_, std::adopt_lock);//ustd::unique_lock能实现自动加锁与解锁功能，第一个参数是指的传入的参数进行上锁，如果有第二个参数即 std::adopt_lock:表示这个互斥量已经被lock()过了,无需在本次构造函数中加锁，否则会报错。</span><br><span class="line"></span><br><span class="line">  cv_.wait(lock); // wait 方法会对互斥锁解锁，然后阻塞等待，一直到被notify唤醒。唤醒之后会再次获取锁，一直到获取锁成功后才继续往下执行。 </span><br><span class="line">  lock.release(); // 检测当前锁是否没有释放，如果是则释放掉</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说每次写入在Wait过程中，会释放当前获取的锁，允许后面的writer 写入到writers中。</p>
<p>下面举例说明：</p>
<p>如果当前有<code>t1</code>,<code>t2</code>,<code>t3</code>,并发写入。假设初始阶段writers为空：</p>
<ol>
<li><code>t1</code>,<code>t2</code>,<code>t3</code> 写入的时候，首先假设<code>t1</code> 首先执行MutexLock l(&amp;mutex_); 即获取到了mutex_的锁，<code>t1</code> 被写入到writers中，而且是作为队头，所以不需要进入Wait状态，直接开始写，此时<code>t2</code>,<code>t3</code> 在等待获取锁。</li>
<li><code>t1</code> 执行到了mutex_.Unlock();此时<code>t1</code>的writer 还在队头，所以<code>t2</code>,<code>t3</code> 被写入到writers中等待唤醒。</li>
<li>此时writers中包含了<code>t2</code>,<code>t3</code>，但是<code>t1</code>只会写自己的数据，因为他是在合并后才释放锁让<code>t2</code>,<code>t3</code>进入的.<code>t1</code>先写入Log，然后写入MemTable，此时不存在并发写的情况，因为其他的并发都会被放到writers中。</li>
<li>等到<code>t1</code>将自己的数据写入到Log 和MemTable后，<code>t1</code> 再次获取到锁，此时阻塞writers的中继续新增writer。</li>
<li>因为<code>t1</code> 的没有进行操作合并，所以他不会唤醒其他的写，只会唤醒下一次的队头，但是此时并没有释放锁。只是唤醒了<code>t2</code>,<code>t2</code>在等待<code>t1</code>释放锁。</li>
<li><code>t1</code> 本次写入返回，方法栈中的MutexLock 被释放，然后<code>t2</code>获取到锁，此时writers中的数据有<code>t3</code>和<code>t2</code></li>
<li><code>t2</code> 的操作相比<code>t1</code> 多了一个合并数据和唤醒的动作。这里就不赘述了。</li>
</ol>
<p>上文中一个就涉及到1个锁，却能够有效的将数据的顺序和并发全部完成。使用一个队列，将多线程写入转换为单线程写入，保证了顺序，也有效地保证了效率。</p>
<h3 id="校验空间容量"><a href="#校验空间容量" class="headerlink" title="校验空间容量"></a>校验空间容量</h3><p>在写入之前，还需要看下当前的内存空间，和level0的文件数，实现就在<code>db/db_impl.cc</code>的MakeRoomForWrite方法中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DBImpl::MakeRoomForWrite</span><span class="params">(<span class="type">bool</span> force)</span> &#123;</span><br><span class="line">  mutex_.AssertHeld(); <span class="comment">// 确认当前的线程获取到了锁</span></span><br><span class="line">  assert(!writers_.empty()); <span class="comment">// 有writer 操作</span></span><br><span class="line">  <span class="type">bool</span> allow_delay = !force; <span class="comment">// 是否运行缓冲，默认是1ms</span></span><br><span class="line">  Status s; <span class="comment">// 返回的状态</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!bg_error_.ok()) &#123; <span class="comment">// 这个bg_error是后台合并level0 的时候的一个操作</span></span><br><span class="line">      <span class="comment">// Yield previous error</span></span><br><span class="line">      s = bg_error_;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">//1 如果允许等待（正常写入可以等待。force==updates==nullptr）,并且当前的0层</span></span><br><span class="line">      <span class="comment">// 文件触发了需要等待的条件（0 层文件大于等于8）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allow_delay &amp;&amp; versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;=</span><br><span class="line">                                  config::kL0_SlowdownWritesTrigger) &#123;</span><br><span class="line">      <span class="comment">// We are getting close to hitting a hard limit on the number of</span></span><br><span class="line">      <span class="comment">// L0 files.  Rather than delaying a single write by several</span></span><br><span class="line">      <span class="comment">// seconds when we hit the hard limit, start delaying each</span></span><br><span class="line">      <span class="comment">// individual write by 1ms to reduce latency variance.  Also,</span></span><br><span class="line">      <span class="comment">// this delay hands over some CPU to the compaction thread in</span></span><br><span class="line">      <span class="comment">// case it is sharing the same core as the writer.</span></span><br><span class="line">      mutex_.Unlock();<span class="comment">// 首先会释放锁，因为此时会等待操作进行完成，没必要不让后续的写入进入</span></span><br><span class="line">      env_-&gt;SleepForMicroseconds(<span class="number">1000</span>);<span class="comment">// 等到1ms</span></span><br><span class="line">      allow_delay = <span class="literal">false</span>;  <span class="comment">// Do not delay a single write more than once,每次写入最多运行等待一次</span></span><br><span class="line">      mutex_.Lock(); <span class="comment">// 加锁，说明要开始干活了</span></span><br><span class="line">      <span class="comment">//2 如果当前的内存足够，而且level0 的文件数量没有超过最大，说明有足够的内存和文件，直接返回stats</span></span><br><span class="line">        <span class="comment">// write_buffer_size 大小为4MB，也就是说一个内存文件大小一般在大于4MB的时候就需要切换了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!force &amp;&amp;</span><br><span class="line">               (mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) &#123;</span><br><span class="line">      <span class="comment">// There is room in current memtable</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">//3 如果正在执行内存文件的合并，则等待内存文件合并完成</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ != nullptr) &#123; </span><br><span class="line">      <span class="comment">// We have filled up the current memtable, but the previous</span></span><br><span class="line">      <span class="comment">// one is still being compacted, so we wait.</span></span><br><span class="line">      Log(options_.info_log, <span class="string">&quot;Current memtable full; waiting...\n&quot;</span>);</span><br><span class="line">      background_work_finished_signal_.Wait();</span><br><span class="line">      <span class="comment">//4 如果有太多的level0层文件（默认12）。则等待文件合并完成</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;= config::kL0_StopWritesTrigger) &#123;</span><br><span class="line">      <span class="comment">// There are too many level-0 files.</span></span><br><span class="line">      Log(options_.info_log, <span class="string">&quot;Too many L0 files; waiting...\n&quot;</span>);</span><br><span class="line">      background_work_finished_signal_.Wait();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//5 如果当前的文件数量小于8，内存资源不够，而且没有进行合并，则说明需要创建一个新的内存文件</span></span><br><span class="line">      <span class="comment">// Attempt to switch to a new memtable and trigger compaction of old</span></span><br><span class="line">      assert(versions_-&gt;PrevLogNumber() == <span class="number">0</span>);</span><br><span class="line">       <span class="comment">// 文件的名称也就是num 也是version提供的</span></span><br><span class="line">      <span class="type">uint64_t</span> new_log_number = versions_-&gt;NewFileNumber();</span><br><span class="line">      WritableFile* lfile = nullptr;</span><br><span class="line">        <span class="comment">// 创建可写文件，创建失败则说明岗前的num可以重复使用</span></span><br><span class="line">      s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">        <span class="comment">// Avoid chewing through file number space in a tight loop.</span></span><br><span class="line">        versions_-&gt;ReuseFileNumber(new_log_number);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">	<span class="comment">// 释放当前的Log文件</span></span><br><span class="line">      delete log_;</span><br><span class="line">	<span class="comment">// 关闭当前的Log文件</span></span><br><span class="line">      s = logfile_-&gt;Close();</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">        <span class="comment">// We may have lost some data written to the previous log file.</span></span><br><span class="line">        <span class="comment">// Switch to the new log file anyway, but record as a background</span></span><br><span class="line">        <span class="comment">// error so we do not attempt any more writes.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// We could perhaps attempt to save the memtable corresponding</span></span><br><span class="line">        <span class="comment">// to log file and suppress the error if that works, but that</span></span><br><span class="line">        <span class="comment">// would add more complexity in a critical code path.</span></span><br><span class="line">        RecordBackgroundError(s);</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">      delete logfile_;</span><br><span class="line">	<span class="comment">// 将上面创建的文件复制写Log，成为新的Log日志文件</span></span><br><span class="line">      logfile_ = lfile;</span><br><span class="line">        <span class="comment">// 设置num</span></span><br><span class="line">      logfile_number_ = new_log_number;</span><br><span class="line">        <span class="comment">// 将创建的文件赋值给Log中的writer</span></span><br><span class="line">      log_ = new <span class="built_in">log</span>::Writer(lfile);</span><br><span class="line">      <span class="comment">// 将当前mem_ 的指针复制给imm_，说明当前的mem已经准备刷到level0 了。</span></span><br><span class="line">      imm_ = mem_;</span><br><span class="line">       <span class="comment">// 设置是has_imm_ 为true，这里的 memory_order_release 前面说过，就是不允许指令重排</span></span><br><span class="line">      has_imm_.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">        <span class="comment">// 创建新的MemTable，传入当前的比较器</span></span><br><span class="line">      mem_ = new MemTable(internal_comparator_);</span><br><span class="line">      <span class="comment">// 给当前的mem 添加引用</span></span><br><span class="line">      mem_-&gt;Ref();</span><br><span class="line">      force = <span class="literal">false</span>;  <span class="comment">// Do not force another compaction if have room</span></span><br><span class="line">        <span class="comment">//尝试调用后台合并</span></span><br><span class="line">      MaybeScheduleCompaction();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里分配的空间核心还是内存是否超过4MB，以及当前level0 的数据是否超过配置的阈值。如果说调大上面的值肯定可以提高一定的吞吐量。但是后期合并的数据量也对应会增加，个人觉得如果key，value 都比较小，则4MB就足够了，但是如果每次都是超大的key和value，就可以考虑调大方法中的参数，避免频繁合并。</p>
<h3 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h3><p>合并操作个人觉得没有什么好了解的，里面有个小tips就是直接对writers的迭代iter++ 这样可以有效的避免其实只有一个还需要走下面的合并操作。</p>
<h3 id="开始写入MemTable"><a href="#开始写入MemTable" class="headerlink" title="开始写入MemTable"></a>开始写入MemTable</h3><p>在写入完Log 后就开始执行写入MemTable了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> status = WriteBatchInternal::InsertInto(write_batch, mem_);</span><br><span class="line">Status <span class="title function_">WriteBatchInternal::InsertInto</span><span class="params">(<span class="type">const</span> WriteBatch* b, MemTable* memtable)</span> &#123;</span><br><span class="line">  MemTableInserter inserter;</span><br><span class="line">  inserter.sequence_ = WriteBatchInternal::Sequence(b);</span><br><span class="line">  inserter.mem_ = memtable;</span><br><span class="line">  <span class="keyword">return</span> b-&gt;Iterate(&amp;inserter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是创建了一个inserter的对象，赋值mem和sequence，然后调用WriteBatch的迭代器写入。这么封装有什么好处呢？为什么不在MemTable里做一个循环直接往里面写呢？个人觉得是为了解耦，MemTable插入的数据就是简单的Slice 对象，而不用去考虑里面的batch，通过迭代器解析然后插入，能够将WriteBatch的职责和MemTable的职责做一个很好的区分。</p>
<p>在正式进入迭代方法之前，先来看下此时一个的WriteBatch 数据结构。这里就不贴全部的源码了，只是说下WriteBatch里面主要是一个Slice的key和Slice 的value。这些值最后都会被挡在一个string类型名为rep_参数中。</p>
<p>每次写入都会将当前操作类型即ValueType放入到req中，写入之后的seq为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果是kTypeValue则数据是 [seq预留<span class="number">8</span>字节，全部为<span class="number">0</span>][count][kTypeValue(<span class="number">1</span>字节)][key_length][key_value][value_length][value_value]</span><br><span class="line">如果是kTypeDeletion 则数据为[seq预留<span class="number">8</span>字节，全部为<span class="number">0</span>][count][kTypeDeletion(<span class="number">1</span>字节)][key_length][key_value]</span><br></pre></td></tr></table></figure>

<p>然后在BuildBatchGroup 中也只是对这个值进行一个追加，最后是一个大的WriteBatch，包含了n个写入，这个在WriteBatch 中是一个append，每次都会将需要append的数据截取12字节后面的数据，然后将count重新设置到被append的count中。执行完BuildBatchGroup 后，就会在前面的4个字节中写入sequence。</p>
<p>结合Log来看，这里的key，value的值都是使用的Varint32位，这也是为什么需要在Log中写入Fragement的原因了。</p>
<p>了解到了WriteBatch 的数据结构就不在去看WriteBatch::Iterate里面的源码里，其实就是根据数据结果解析为key和value，然后分为delete方法或者Put方法。但是需要注意的是，WriteBatch::Iterate的里面的Put方法最后走到了<code>class MemTableInserter : public WriteBatch::Handler </code>这个类里面的Put方法里。这个方法会对核心就是对当前批次写入的sequence进行解析和插入到MemTable中，说明虽然我们合并了数据的写入，但是在写入Mem中的时候sequence 还是按照写入顺序+1 的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Put</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> override &#123;</span><br><span class="line">  mem_-&gt;Add(sequence_, kTypeValue, key, value);</span><br><span class="line">  sequence_++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> override &#123;</span><br><span class="line">  mem_-&gt;Add(sequence_, kTypeDeletion, key, Slice());</span><br><span class="line">  sequence_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LevelDB里面的迭代器目前已经了解了两个了，一个是MemTable中的Iterator，用来查询数据，还有一个就是当前的写入了，其实迭代器在LevelDB中使用比较多，后面全部过一遍再回头来看迭代器的使用。</p>
<h3 id="Add-方法"><a href="#Add-方法" class="headerlink" title="Add 方法"></a>Add 方法</h3><p>看到这里，终于开始往MemTable 写数据了。具体实现比较简单，主要就是Key值的创建也就是SkipList中Node 的创建。具体代码实现在<code>db/mem_table.cc</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MemTable::Add</span><span class="params">(SequenceNumber s, ValueType type, <span class="type">const</span> Slice&amp; key,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> Slice&amp; value)</span> &#123;</span><br><span class="line">  <span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">  <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">  <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">  <span class="comment">//  tag          : uint64((sequence &lt;&lt; 8) | type) // 将type 放在seq后面</span></span><br><span class="line">  <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">  <span class="comment">//  value bytes  : char[value.size()]</span></span><br><span class="line">  <span class="type">size_t</span> key_size = key.size();</span><br><span class="line">  <span class="type">size_t</span> val_size = value.size();</span><br><span class="line">  <span class="type">size_t</span> internal_key_size = key_size + <span class="number">8</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> encoded_len = VarintLength(internal_key_size) +</span><br><span class="line">                             internal_key_size + VarintLength(val_size) +</span><br><span class="line">                             val_size;</span><br><span class="line">  <span class="type">char</span>* buf = arena_.Allocate(encoded_len); <span class="comment">//创建当前encode 后的数据大小的内存，ie：指向0x8060f8</span></span><br><span class="line">  <span class="type">char</span>* p = EncodeVarint32(buf, internal_key_size);<span class="comment">// 将internal_key_size的值放入到buf中，返回指向 //0x8060f9</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(p, key.data(), key_size);<span class="comment">// 将key的值放入到p指针</span></span><br><span class="line">  p += key_size; <span class="comment">//因为key的值有6个</span></span><br><span class="line">  EncodeFixed64(p, (s &lt;&lt; <span class="number">8</span>) | type);</span><br><span class="line">  p += <span class="number">8</span>; <span class="comment">//0x8060ff 仍然指向</span></span><br><span class="line">  p = EncodeVarint32(p, val_size);<span class="comment">//0x806107</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(p, value.data(), val_size);</span><br><span class="line">  assert(p + val_size == buf + encoded_len);</span><br><span class="line"><span class="comment">//  for (size_t i = 0; i &lt; encoded_len; ++i) &#123;</span></span><br><span class="line"><span class="comment">//    unsigned char c = static_cast&lt;unsigned char&gt;(buf[i]);</span></span><br><span class="line"><span class="comment">//    std::bitset&lt;8&gt; binary(c); // 将字符转换为 8 位二进制</span></span><br><span class="line"><span class="comment">//    std::cout &lt;&lt; &quot;Character: &quot; &lt;&lt; buf[i] &lt;&lt; &quot;  Binary: &quot; &lt;&lt; binary &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">  table_.Insert(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ValueType的值就是上面提到的MemTableInserter  中put或者delete来传入的。</p>
<p>然后就是写入MemTable的Key的的构建了，最后构建的结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[internal_key_size_length Varint64][key_length][key_value][tag[sequence&lt;&lt;<span class="number">8</span>|type] <span class="number">8</span>字节][value_length][value_value]</span><br></pre></td></tr></table></figure>

<p><img src="http://image.mingyouxiaozhu.top/blog/memTable_innerkey1.png" alt="memTable_innerkey1"></p>
<p>然后就是开辟内存空间，传入的参数为上面的所有值长度之和：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title function_">Arena::Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> &#123;</span><br><span class="line">  <span class="comment">// The semantics of what to return are a bit messy if we allow</span></span><br><span class="line">  <span class="comment">// 0-byte allocations, so we disallow them here (we don&#x27;t need</span></span><br><span class="line">  <span class="comment">// them for our internal use).</span></span><br><span class="line">  assert(bytes &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 如果当前的内存小于剩下的内存，则直接在剩下的内存中进行分配</span></span><br><span class="line">  <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    <span class="type">char</span>* result = alloc_ptr_;</span><br><span class="line">    alloc_ptr_ += bytes;</span><br><span class="line">    alloc_bytes_remaining_ -= bytes;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> AllocateFallback(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上次开辟的空间未使用大于本次使用的空间，直接使用，否则就新创建空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">Arena::AllocateFallback</span><span class="params">(<span class="type">size_t</span> bytes)</span> &#123;</span><br><span class="line">  <span class="comment">// 当前的额分配的是否大于1k，如果大于1k直接开通当前的数量</span></span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// Object is more than a quarter of our block size.  Allocate it separately</span></span><br><span class="line">    <span class="comment">// to avoid wasting too much space in leftover bytes.</span></span><br><span class="line">    <span class="type">char</span>* result = AllocateNewBlock(bytes);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果超过1k，创建4k的内存</span></span><br><span class="line">  <span class="comment">// We waste the remaining space in the current block.</span></span><br><span class="line">  alloc_ptr_ = AllocateNewBlock(kBlockSize);</span><br><span class="line">  alloc_bytes_remaining_ = kBlockSize;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>* result = alloc_ptr_;</span><br><span class="line">  alloc_ptr_ += bytes;</span><br><span class="line">  alloc_bytes_remaining_ -= bytes;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Log中提到，每次读取都是4kb，所以这里每一个Block也是4kb。仅仅分为两种情况，超过1kb的直接分配需要的内存数，否则直接分配4kb，具体的内存分配在AllocateNewBlock：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将创建的内存方在blocks_的链表中，然后给memory_usage_ 的值添加一下</span></span><br><span class="line"><span class="comment">//memory_usage_  记录的就是当前memtable 使用的内存大小，如果超过配置的最大缓存值，会将内存数据写入到磁盘上</span></span><br><span class="line"><span class="comment">// 内存分配就是很简单的创建一个char数组，然后push到队列中。</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">Arena::AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span> &#123;</span><br><span class="line">  <span class="type">char</span>* result = new <span class="type">char</span>[block_bytes];</span><br><span class="line">  blocks_.push_back(result);</span><br><span class="line">  memory_usage_.fetch_add(block_bytes + <span class="keyword">sizeof</span>(<span class="type">char</span>*),</span><br><span class="line">                          <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到内存分配非常简单，就是将分配一个char数组，然后放入到blocks的vector里面。为什么可以这么简单的管理呢？这个和Area的生命周期相关，因为一个MemTable包含了一个Area独占的对象，当前MemTable如果释放了空间，说明当前的MemTable没有被其他人引用，而且已经写入到level0的sstable里了，所以area里面的空间可以直接释放。因为不会有人正在访问该空间了。</p>
<p>分配完成以后，就直接写入到SkiptList里面，MemTable的传入的Comparator 也就是MemTable使用的Comparator了。</p>
<h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p>首先还是看<code>db/db_impl.cc</code>中的Get方法,实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DBImpl::Get</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options, <span class="type">const</span> Slice&amp; key,</span></span><br><span class="line"><span class="params">                   <span class="built_in">std</span>::<span class="built_in">string</span>* value)</span> &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  MutexLock <span class="title function_">l</span><span class="params">(&amp;mutex_)</span>; <span class="comment">// 加锁，这里加锁的主要原因是需要获取当前的全局变量versions_，然后获取到sequence的值</span></span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  <span class="keyword">if</span> (options.snapshot != nullptr) &#123;</span><br><span class="line">    snapshot =</span><br><span class="line">        static_cast&lt;<span class="type">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;sequence_number();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    snapshot = versions_-&gt;LastSequence();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  MemTable* mem = mem_; <span class="comment">// 当前正在写的Memtable</span></span><br><span class="line">  MemTable* imm = imm_;<span class="comment">// 准备收入level0的MemTable，只读MemTable</span></span><br><span class="line">  Version* current = versions_-&gt;current(); <span class="comment">//当前的version对象</span></span><br><span class="line">  mem-&gt;Ref(); <span class="comment">// 给mem 新增一个引用，避免读取过程中该mem被回收</span></span><br><span class="line">  <span class="keyword">if</span> (imm != nullptr) imm-&gt;Ref();<span class="comment">// 给imm 新增一个引用，</span></span><br><span class="line">  current-&gt;Ref(); <span class="comment">// version也增加引用</span></span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> have_stat_update = <span class="literal">false</span>;</span><br><span class="line">  Version::GetStats stats;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock(); <span class="comment">// 释放锁，因为当前影响读取的version 或者sequence已经获取到了，所以不在会访问这些全局变量，而且mem和mem_也不会被回收。这里留下个问题，如果说当前读取操作的时候，mem和imm 都满了，等着写，那么岂不是也要等待数据读完？个人觉得是不会的，因为Imm已经在此处变成了本地变量，所以如果合并的时候已经被清理，那么是否回收这个imm的对象就交给了当前查询过程中的这个方法，即变成了栈空间对象的回收</span></span><br><span class="line">    <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">    LookupKey <span class="title function_">lkey</span><span class="params">(key, snapshot)</span>;<span class="comment">// 创建查看的key，</span></span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;Get(lkey, value, &amp;s)) &#123; </span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != nullptr &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">      <span class="comment">// Done</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = current-&gt;Get(options, lkey, value, &amp;stats);</span><br><span class="line">      have_stat_update = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) &#123;</span><br><span class="line">    MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  mem-&gt;Unref();</span><br><span class="line">  <span class="keyword">if</span> (imm != nullptr) imm-&gt;Unref();</span><br><span class="line">  current-&gt;Unref();</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个LookupKey 核心实现就是组装当前查的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[key_length][user_key][tag]</span><br></pre></td></tr></table></figure>

<p><img src="http://image.mingyouxiaozhu.top/blog/memP_lookUpkey.png" alt="memP_lookUpkey"></p>
<p>总的来说还是通过internal_key 查找，所以查找的比较器就比较重要，这里来看下实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InternalKeyComparator::Compare</span><span class="params">(<span class="type">const</span> Slice&amp; akey, <span class="type">const</span> Slice&amp; bkey)</span> <span class="type">const</span> &#123;</span><br><span class="line">  <span class="comment">// Order by:</span></span><br><span class="line">  <span class="comment">//    increasing user key (according to user-supplied comparator)</span></span><br><span class="line">  <span class="comment">//    decreasing sequence number</span></span><br><span class="line">  <span class="comment">//    decreasing type (though sequence# should be enough to disambiguate)</span></span><br><span class="line">  <span class="type">int</span> r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> anum = DecodeFixed64(akey.data() + akey.size() - <span class="number">8</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> bnum = DecodeFixed64(bkey.data() + bkey.size() - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (anum &gt; bnum) &#123;</span><br><span class="line">      r = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (anum &lt; bnum) &#123;</span><br><span class="line">      r = +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照key的值和sequence的值进行比较，都是使用uint64_t比较的，因为sequence取的是后24位，所以大小比较key有效过滤key值相等不同seq的值。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文介绍了MemTable的实现，还包含了具体的写入过程中的锁。LevelDB对锁的处理，内存的处理是十分指的学习的。但是每次都将Value的值也一起放入到内存，写入到SkipList里，个人觉得对大对象的存储和查询造成了很多内存上的浪费和使用。是否可以考虑存储计算分离，将Value的值和Key值分开，然后不断修改Key中的Value的offset就行了。有个初步的设想，首先Key记录的是Value的offset，磁盘或者内存，在合并的时候去查询，查到数据执行更新，比自己旧的数据可以进行删除和回收。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/05/LevelDB%E4%B9%8BLog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mingyouxiaozhu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingyouxiaozhu's blog">
      <meta itemprop="description" content="enjoy life ,enjoy coding">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | mingyouxiaozhu's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/05/LevelDB%E4%B9%8BLog/" class="post-title-link" itemprop="url">LevelDB之Log</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-05 09:52:57 / 修改时间：19:10:11" itemprop="dateCreated datePublished" datetime="2023-09-05T09:52:57+08:00">2023-09-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇的文章中，将 LevelDB 的架构做了一个简单的介绍。分析了需要的各个模块，后文将针对各个模块做一个更加详细的介绍。在介绍的过程中，希望能够了解到为什么这么做。</p>
<h1 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Log 本身就是一个 WAL 日志，将每次写入的改变数据的操作首先持久化到文件，因为数据是顺序写入的所以写入性能高。又因为是每次首先都记录在 WAL 日志中然后进行具体的操作，所以根据 WAL 日志能够在系统意外崩溃的情况下恢复到崩溃前的状态，不会出现客户端已经返回成功，但是数据丢失的情况。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="具体实现位置"><a href="#具体实现位置" class="headerlink" title="具体实现位置"></a>具体实现位置</h3><p>Log 涉及到的主要就是读写.<br>写操作就是 WAL 日志，顺序写入操作到磁盘，主要实现在：</p>
<ul>
<li>db&#x2F;log_writer.cc</li>
<li>db&#x2F;log_writer.h</li>
</ul>
<p>读操作就是在系统重启后从 WAL 日志恢复，也是顺序读取。和 Writer 感觉就是队列一个，一个队头读，一个队尾写。主要实现在：</p>
<ul>
<li>db&#x2F;log_reader.cc</li>
<li>db&#x2F;log_reader.h</li>
</ul>
<p>在写的过程中还涉及到日志的序列化和反序列化。这部分的实现是在：</p>
<ul>
<li>db&#x2F;log_format.h</li>
</ul>
<p>当然不同的操作系统对底层调用如文件读写是不一样的，LevelDB 使用了一个 env 来统一上层操作，然后不同环境在编译器自动实现。具体位置在：</p>
<ul>
<li>util&#x2F;env.cc</li>
</ul>
<p>在 env 中，包含了多个类。其中和文件相关的类有：</p>
<ol>
<li>SequentialFile 从一个文件顺序读</li>
<li>RandomAccessFile 随机读取某个文件</li>
<li>WritableFile 顺序写的文件，注意的是，在 env 中说明了，这个类需要提供一个 buffer，可以让小的 fragments 能够合并一起刷入磁盘</li>
</ol>
<blockquote>
<p>上面提到的读写和序列化的三个都属于 log 的 namespce。<code>namespace</code> 是一种用于组织和管理命名空间的机制。命名空间是用来避免名称冲突（名称重复）的一种方式，尤其在大型项目中非常有用，以确保不同部分的代码可以使用相同的名称而不产生冲突。而且 namespace 是可以嵌套的。</p>
<p>个人将它类比为 java 的 package</p>
</blockquote>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>为了减少磁盘 IO，LevelDB 每次读取文件都会读取 4kb 的数据，具体实现后文会说。为了让一次性读取的数据读取到当前刚好能处理的数据，所以写入的过程中也针对 4kb 做了操作。这个 4Kb 大小的数据在 LevelDB 中称之为 Block，写入的数据或者读取的数据被称为 Record，但是并不是每次写入的数据都刚好等于 4Kb，所以针对这种情况，又将存储在 Block 中的数据切割成 Fagement。组织如下图所示：</p>
<p><img src="/./LevelDB%E4%B9%8BLog.assets/log_file_format-1693898015414.png" alt="log_file_format"></p>
<p>上图为 logfile 的里面数据的组织结果，一次写入称之为 Record，一个 Record 会被切分成一个或多个 fragement 中分布在一个或者多个 block 中，每次读取是一个 block，但是每次写入只是写入一个 fragement。</p>
<h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p>LevelDB 会为每次写入封装一个 Writer 对象，这个对象定义在<code>db/log_writer.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> &#123;</span></span><br><span class="line"> public:</span><br><span class="line">  <span class="comment">// Create a writer that will append data to &quot;*dest&quot;.</span></span><br><span class="line">  <span class="comment">// &quot;*dest&quot; must be initially empty.</span></span><br><span class="line">  <span class="comment">// &quot;*dest&quot; must remain live while this Writer is in use.</span></span><br><span class="line">  explicit <span class="title function_">Writer</span><span class="params">(WritableFile* dest)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a writer that will append data to &quot;*dest&quot;.</span></span><br><span class="line">  <span class="comment">// &quot;*dest&quot; must have initial length &quot;dest_length&quot;.</span></span><br><span class="line">  <span class="comment">// &quot;*dest&quot; must remain live while this Writer is in use.</span></span><br><span class="line">  Writer(WritableFile* dest, <span class="type">uint64_t</span> dest_length);</span><br><span class="line"></span><br><span class="line">  Writer(<span class="type">const</span> Writer&amp;) = delete;</span><br><span class="line">  Writer&amp; operator=(<span class="type">const</span> Writer&amp;) = delete;</span><br><span class="line"></span><br><span class="line">  ~Writer();</span><br><span class="line"></span><br><span class="line">  Status <span class="title function_">AddRecord</span><span class="params">(<span class="type">const</span> Slice&amp; slice)</span>;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  Status <span class="title function_">EmitPhysicalRecord</span><span class="params">(RecordType type, <span class="type">const</span> <span class="type">char</span>* ptr, <span class="type">size_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line">  WritableFile* dest_;</span><br><span class="line">  <span class="type">int</span> block_offset_;  <span class="comment">// Current offset in block</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// crc32c values for all supported record types.  These are</span></span><br><span class="line">  <span class="comment">// pre-computed to reduce the overhead of computing the crc of the</span></span><br><span class="line">  <span class="comment">// record type stored in the header.</span></span><br><span class="line">  <span class="type">uint32_t</span> type_crc_[kMaxRecordType + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>公有域：</p>
<ul>
<li>AddRecord 方法，用于外部写入 Slice</li>
</ul>
<p>私有域：</p>
<ul>
<li>EmitPhysicalRecord 用于写入磁盘</li>
<li>dest_ env 中提供的一个写文件的封装，可以理解位一个已经打开的可以写入的文件</li>
<li>block<em>offset</em> 当前 writer 写入的 block 位置</li>
<li>type<em>crc</em> ，这个是一个数组，里面存储的是当前的 type 对应的 crc，因为 type 是一个常量，不需要每次都计算。</li>
</ul>
<h5 id="AddRecord"><a href="#AddRecord" class="headerlink" title="AddRecord"></a>AddRecord</h5><p>AddRecord 本身的实现主要就是对当前写入 Record 做切割成 Fragement，具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Writer::AddRecord</span><span class="params">(<span class="type">const</span> Slice&amp; slice)</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* ptr = slice.data();</span><br><span class="line">  <span class="type">size_t</span> left = slice.size();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fragment the record if necessary and emit it.  Note that if slice</span></span><br><span class="line">  <span class="comment">// is empty, we still want to iterate once to emit a single</span></span><br><span class="line">  <span class="comment">// zero-length record</span></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="type">bool</span> begin = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//当前的block中的剩下的值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> leftover = kBlockSize - block_offset_;</span><br><span class="line">    assert(leftover &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果小于7 ，则全部填满为0</span></span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123;</span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        <span class="keyword">static_assert</span>(kHeaderSize == <span class="number">7</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        dest_-&gt;Append(Slice(<span class="string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>, leftover));</span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span></span><br><span class="line">    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="comment">// 一个block中的每一个fragment的大小，left为本次写入过程中待写入的数量，avail为可以写入的长度</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> end = (left == fragment_length); <span class="comment">// 如果当前待写入的数据量小于block可以使用的，则说明本次可以作为一个完整的写入</span></span><br><span class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123;</span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123; <span class="comment">// 如果第一次待写入的数据库大于可以使用的，则需要进行切段，并且标记</span></span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123; <span class="comment">// 再循环中，如果前面的写入都完成了，那么最后可能是写入一个完整的数据，并且将它标记为最后的fragment</span></span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 在循环中，写入第一个后，后面仍然不足够，则需要进行切分为多个，既然不是开始也不是最后，则是处于中间的数据量</span></span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line">    s = EmitPhysicalRecord(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    begin = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.ok() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的 kBlockSize 初始值在<code>util/log_format.h</code>中的 kBlockSize,大小是 32768 字节也就是 32kb。block<em>offset</em>则是 writer 对象中写入成功后会更新的值。</p>
<p>实现的流程核心分为以下判断：</p>
<ol>
<li>当前 block 中剩下的值是否不能写入一个 header 即 7 个字节，如果小于则直接填充 0，所以给实际数据写入的值为 avail，即等于 整个 blog 剩下的值减去 header 的 7 个字节</li>
<li>如果当前的 block 的 avail 大小大于需要写入的数据，则当前 fragement 的长度就等于需要写入的长度，也就是一个 fullfragement，否则只能写入剩下可以写的大小</li>
<li>判断当前的 fragement 的类型是通过 2 个参数确定的。<ol>
<li>begin 在第一次进入方法时候为 true</li>
<li>end 如果当前剩下的可写长度比 fragement 的长度长，则 end 为 true，否则为 false</li>
<li>如果 end 和 begin 都为 true，则是一个 fragement，如果两者中只有一个为 true，则要么是最后一个，要么是第一个，两个都为 false，则说明是 kMiddleType。</li>
</ol>
</li>
</ol>
<p>确认好 type 后，也就确认了当前 fragement，也就是可以进行数据的持久化了，即调用了 EmitPhysicalRecord 方法：</p>
<h5 id="EmitPhysicalRecord"><a href="#EmitPhysicalRecord" class="headerlink" title="EmitPhysicalRecord"></a>EmitPhysicalRecord</h5><p>EmitPhysicalRecord 方法具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Writer::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="type">const</span> <span class="type">char</span>* ptr,</span></span><br><span class="line"><span class="params">                                  <span class="type">size_t</span> length)</span> &#123;</span><br><span class="line">  assert(length &lt;= <span class="number">0xffff</span>);  <span class="comment">// Must fit in two bytes</span></span><br><span class="line">  assert(block_offset_ + kHeaderSize + length &lt;= kBlockSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Format the header</span></span><br><span class="line">  <span class="type">char</span> buf[kHeaderSize];</span><br><span class="line">  buf[<span class="number">4</span>] = static_cast&lt;<span class="type">char</span>&gt;(length &amp; <span class="number">0xff</span>); <span class="comment">// 将长度的低8位放到第四个位置</span></span><br><span class="line">  buf[<span class="number">5</span>] = static_cast&lt;<span class="type">char</span>&gt;(length &gt;&gt; <span class="number">8</span>); <span class="comment">//  char是一个字节，所以这里也是一个字节。可以看到是小端数组，低八位放在前面，然后最多两个字节表示带下，最多一次性写入16k的数据</span></span><br><span class="line">  buf[<span class="number">6</span>] = static_cast&lt;<span class="type">char</span>&gt;(t); <span class="comment">// 当前fragment的类型放在6 这个位置</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="type">uint32_t</span> crc = crc32c::Extend(type_crc_[t], ptr, length);</span><br><span class="line">  crc = crc32c::Mask(crc);  <span class="comment">// Adjust for storage</span></span><br><span class="line">  EncodeFixed32(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the header and the payload</span></span><br><span class="line">  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize));</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = dest_-&gt;Append(Slice(ptr, length));</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = dest_-&gt;Flush();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  block_offset_ += kHeaderSize + length;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是拼接头节点，这里不是从头到尾来做的，而是首先将长度和 type 放入，具体的数据结构可以看上面的图中的 fragement 里面的头节点类容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buff[6] = char[6]&#123;crc_low,crc_mid0,crc_mid2,crc_high,length_low,length_high,type&#125;</span><br></pre></td></tr></table></figure>

<p>和 Varint 类似，甚至前面 4 个 crc 就是使用的 EncodeFixed32，固定长度的 char 表示 32 位整型。都是小端存储。</p>
<p>封装好 header 后，首先将 header 的数据 append 到 dest_ 中，成功后 append 数据，append 成功后会调用 flush，将本次的 record 刷入到磁盘上。</p>
<p>整个写流程就完成了，此时 Log 中已经包含了本次写入的 Record。</p>
<h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p>前文提到，每次写入都会将 Record 写入到磁盘上作为 WAL 日志，WAL 日志的读取只有一个地方会做，就是数据库重启后的恢复动作。但是数据库的恢复动作除了读取 Record 还涉及到很多其他的如版本等的操作。读操作的篇幅里都不会涉及，在后面了 version 的时候会详细说下，所以本文仅仅涉及到读 Record 的操作。</p>
<h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p>和 Writer 类型，LevelDB 会为每次读取都提供一个 Reader 的对象，实现位置在<code>db/log_reader.h</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span> &#123;</span></span><br><span class="line"> public:</span><br><span class="line">  <span class="comment">// Interface for reporting errors.</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Reporter</span> &#123;</span></span><br><span class="line">   public:</span><br><span class="line">    virtual ~Reporter();</span><br><span class="line">      <span class="comment">// 某些字节可能已经损坏，损坏的</span></span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">Corruption</span><span class="params">(<span class="type">size_t</span> bytes, <span class="type">const</span> Status&amp; status)</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// reader 传入的参数是一个SequentialFile，也就是一个顺序读取的对象</span></span><br><span class="line">  Reader(SequentialFile* file, Reporter* reporter, <span class="type">bool</span> checksum,</span><br><span class="line">         <span class="type">uint64_t</span> initial_offset);</span><br><span class="line">  Reader(<span class="type">const</span> Reader&amp;) = delete;</span><br><span class="line">  Reader&amp; operator=(<span class="type">const</span> Reader&amp;) = delete;</span><br><span class="line">  ~Reader();</span><br><span class="line"><span class="comment">// 将当前Record的数据读取到record里面，读取成功则返回true，如果已经读取到本次输入的尾部，则返回false，并且将数据临时存储在scratch 中</span></span><br><span class="line">  <span class="comment">// Read the next record into *record.  Returns true if read</span></span><br><span class="line">  <span class="comment">// successfully, false if we hit end of the input.  May use</span></span><br><span class="line">  <span class="comment">// &quot;*scratch&quot; as temporary storage.  The contents filled in *record</span></span><br><span class="line">  <span class="comment">// will only be valid until the next mutating operation on this</span></span><br><span class="line">  <span class="comment">// reader or the next mutation to *scratch.</span></span><br><span class="line">  <span class="type">bool</span> <span class="title function_">ReadRecord</span><span class="params">(Slice* record, <span class="built_in">std</span>::<span class="built_in">string</span>* scratch)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns the physical offset of the last record returned by ReadRecord.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Undefined before the first call to ReadRecord.</span></span><br><span class="line">  <span class="type">uint64_t</span> <span class="title function_">LastRecordOffset</span><span class="params">()</span>;</span><br><span class="line"> private:</span><br><span class="line">    <span class="comment">// 有删减</span></span><br><span class="line">  SequentialFile* <span class="type">const</span> file_;</span><br><span class="line">  Reporter* <span class="type">const</span> reporter_;</span><br><span class="line">  <span class="type">bool</span> <span class="type">const</span> checksum_;</span><br><span class="line">  <span class="type">char</span>* <span class="type">const</span> backing_store_;</span><br><span class="line">  Slice buffer_;</span><br><span class="line">  <span class="type">bool</span> eof_;  <span class="comment">// Last Read() indicated EOF by returning &lt; kBlockSize</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Offset of the last record returned by ReadRecord.</span></span><br><span class="line">  <span class="type">uint64_t</span> last_record_offset_;</span><br><span class="line">  <span class="comment">// Offset of the first location past the end of buffer_.</span></span><br><span class="line">  <span class="type">uint64_t</span> end_of_buffer_offset_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Offset at which to start looking for the first record to return</span></span><br><span class="line">  <span class="type">uint64_t</span> <span class="type">const</span> initial_offset_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上文没有贴完整的代码，私有域中的方法和对象我没有完全贴。因为 Reader 方法本身只是将 Record 从 Log 中读取出来，当然其他如 MANIFEST 的文件其实也是按照 Record 来存储的。但是整体上来说，都是从文件中将 Record 的日志恢复，然后按照类型插入到 Memtable 或者 VersionSet 中。</p>
<p>Log 日志恢复主要是在 RecoverLogFile 方法中位于<code>db/db_impl.cc</code>中。这个方法比较长，下文挑一些核心的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; status.ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (record.size() &lt; <span class="number">12</span>) &#123;</span><br><span class="line">    reporter.Corruption(record.size(),</span><br><span class="line">                        Status::Corruption(<span class="string">&quot;log record too small&quot;</span>));</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  WriteBatchInternal::SetContents(&amp;batch, record);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == nullptr) &#123;</span><br><span class="line">    mem = new MemTable(internal_comparator_);</span><br><span class="line">    mem-&gt;Ref();</span><br><span class="line">  &#125;</span><br><span class="line">  status = WriteBatchInternal::InsertInto(&amp;batch, mem);</span><br><span class="line">  MaybeIgnoreError(&amp;status);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">const</span> SequenceNumber last_seq = WriteBatchInternal::Sequence(&amp;batch) +</span><br><span class="line">                                  WriteBatchInternal::Count(&amp;batch) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (last_seq &gt; *max_sequence) &#123;</span><br><span class="line">    *max_sequence = last_seq;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem-&gt;ApproximateMemoryUsage() &gt; options_.write_buffer_size) &#123;</span><br><span class="line">    compactions++;</span><br><span class="line">    *save_manifest = <span class="literal">true</span>;</span><br><span class="line">    status = WriteLevel0Table(mem, edit, nullptr);</span><br><span class="line">    mem-&gt;Unref();</span><br><span class="line">    mem = nullptr;</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      <span class="comment">// Reflect errors immediately so that conditions like full</span></span><br><span class="line">      <span class="comment">// file-systems cause the DB::Open() to fail.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面是从文件中读取 record 的实现，是一个循环读取的过程，上面的方法介绍里说过，reader.ReadRecord(&amp;record, &amp;scratch) 中的两个传入的参数分别为，如果是 fullFragement，则将值放在 record 中，如果是 first，mid 则放在 scratch 中，一直遇到 end 后放到 record 中。</p>
<blockquote>
<p>问题 a：是否存在比如当前有两个日志文件(000001.log,000002.log),然后 000001.log 中的末尾刚好是 000002.log 第一个 fragement 的 header 呢？</p>
</blockquote>
<p>在持续读取过程中，会将 Record 的数据写入到 memtable 中，如果发现 Memtable 的值超过了 4MB，则刷入 level0 层。</p>
<p>循环执行完后，当前的 log 日志已经全部弄到内存中了。如果当前的<code>Options</code>中指定了使用原来的 log 文件，则无需将内存中的数据刷入磁盘，因为 log 文件在后续的写入中继续使用，则将当前恢复 memTable 复制给 mem 对象作为后续写入的 memtable，log 的回收可以走写入的流程过程中的日志文件回收策略，否则的话，仍然需要将当前的数据刷入 level0。因为可能在新写入的操作中，该日志文件被删除，到时候没有刷盘则丢失数据了。</p>
<h2 id="Log-回收和截断"><a href="#Log-回收和截断" class="headerlink" title="Log 回收和截断"></a>Log 回收和截断</h2><p>Log 日志如果不做截断，数据量会持续堆积，越来越大。截断的时机是个比较重要的事件。看上面的 Recover 可以看出一些端倪。如果当前的 memTable 中的数据被刷入到了磁盘，成了 level0，那么就说明可以回收当前对应的 log 文件了。</p>
<p>在<code>db/db_impl.cc</code>中有一个 CompactMemTable，该方法就是将 imm 的数据写入到 level0,然后在数据写入到 level0 的时候就将当前的 log 删除。那么是否可能存在误删除当前写入的数据呢？答案是不会的，因为合并的时候正在写的 log 文件已经变成了新的文件。还记得上面的问题 a 吗？这里得到了答案，就是不可能存在 header 的数据在一个文件，然后 data 的数据在另外一个文件的情况，只有可能出现文件刚好写完 header 系统就挂掉的情况。这种情况在 leveldb 中是作为异常处理的。</p>
<p>日志的切换是在<code>db/db_impl.cc</code>中的 MakeRoomForWrite，当当前的资源不住，主要 i 是 mem 的资源不足的时候，就新建一个 log 文件作为本次写入的文件，然后将原来的文件 close，然后将当前 mem 修改为_mem。而且这个文件是递增命名的，所以根据名字就可以进行先后顺序排序，所以也不存在导致删除错误的情况，至于文件的组织后文在探讨 Version 的时候在讨论。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文将前面的整体架构中的 Log 模块做了介绍，还涉及到了部分 Recover 的情况。在 LevelDB 中，数据基本上都是按照类似的方式不断的 append 的，所以基本上都是 Record 的方式加解密。这部分会在后面的 SSTable，Version 等中在遇到。</p>
<p>个人觉得设计比较有美感的就是 Log 的截取和 fragement 的方式写入，阅读起来很顺畅。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/04/LevelDB%E4%B9%8B%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mingyouxiaozhu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingyouxiaozhu's blog">
      <meta itemprop="description" content="enjoy life ,enjoy coding">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | mingyouxiaozhu's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/04/LevelDB%E4%B9%8B%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">LevelDB之整体架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-04 11:10:46" itemprop="dateCreated datePublished" datetime="2023-09-04T11:10:46+08:00">2023-09-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-05 09:35:15" itemprop="dateModified" datetime="2023-09-05T09:35:15+08:00">2023-09-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面介绍了 LevelDB 中的 Slice，编码和 SkipList 较为基础的组件和实现。本文将介绍下 LevelDB 的整体架构。</p>
<p><img src="E:%5Csource%5Chexo-source%5Csource%5C_posts%5C2023%5CLevelDB%E4%B9%8B%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.assets%5Cleveldb_architure.png" alt="leveldb_architure"></p>
<p>上图是一个比较简陋的架构图。只涉及到数据的读写，没有涉及到如版本控制，文件合并等。下文会按照每个模块稍微讲解下。</p>
<p>首先看下一个 demo 写入数据产生的文件:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000005.l</span>db</span><br><span class="line"><span class="number">000006.l</span>db</span><br><span class="line"><span class="number">000007.l</span>og</span><br><span class="line"><span class="number">000008.l</span>og</span><br><span class="line"><span class="number">000009.l</span>db</span><br><span class="line">CURRENT</span><br><span class="line">LOCK</span><br><span class="line">LOG</span><br><span class="line">LOG.old</span><br><span class="line">MANIFEST<span class="number">-000004</span></span><br></pre></td></tr></table></figure>

<p>其中 LOG 就是输出的系统日志文件</p>
<ul>
<li>ldb 文件即 sstable 文件</li>
<li>log Log 日志，下文的 WAL 日志</li>
<li>CURRENT 存储的是当前的 MANIFEST 文件名称</li>
<li>LOCK 加锁，一个 leveldb 的数据库只能由一个进程打开</li>
<li>MANIFEST 主要保存的是版本数据<ul>
<li>这个文件算的上是一种特殊的 Log 日志文件，里面存储的是 Version 的数据，也就是每次 Version 发生变化都会写入到这个文件中，也是一个 WAL 日志。Version 暂时将他认为就是某一时刻，每一个 Level 中包含的文件等信息</li>
</ul>
</li>
</ul>
<h2 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h2><p>前面提到过 LevelDB 是一个 LSM-Tree，这种数据结构分为两种数据，一个是已经持久化到磁盘上的 SSTable，还有一个就是当前内存中的 SSTable，SSTable 就是 Sorted String Table，按照字符排序的数据。每次插入都是先插入内存，然后在时间或者空间的维度上设置阈值，超过阈值将内存中的刷入到磁盘。查询则是每次先查内存，然后去磁盘上查询。</p>
<p>因为服务端返回一般是写入到内存中就可以直接返回了，所以可能存在当前异常挂掉的时候内存数据丢失。也就是说需要一个系统崩溃后的恢复机制。只要涉及到类似的，先写内存然后异步刷磁盘的场景基本上都是需要这个机制的，这个机制就是 WAL(write-ahead log)，实现方式就是将可能对当前系统内部的数据变更的操作（增删改）操作先顺序写入到磁盘上，在出现系统异常推出后，可以通过读取这个日志将将数据恢复到开始阶段。</p>
<p>不过存在下面的情况，WAL 成功，没有执行操作的时候宕机，只能恢复到上一次完成操作的 WAL 日志位置，这也就意味这实际使用过程中，必须要有一个 ID 来标识当前的操作序列，便于恢复的时候不会返回原本已经报错写入失败的数据被恢复的情况。</p>
<p>LevelDB 中的数据没有删除的概念，删除的时候只是在当前的 Key 中设置一个墓碑标识，表示当前的数据已经被删除了，然后在后续文件合并的时候才会真正删除数据。所以基本上只涉及到曾和改，但是在 KV 数据库中，改也是一种增加，也就是直接覆盖原始数据。</p>
<h2 id="Mem-Table-和-Immutable-Table"><a href="#Mem-Table-和-Immutable-Table" class="headerlink" title="Mem_Table 和 Immutable_Table"></a>Mem_Table 和 Immutable_Table</h2><p>从命名可以看出。immutable_table 是一个不可变的 table。LevelDB 的操作是先将数据写入到 MemTable 中，MemTable 的实现就是一个 SkipList。等到 MemTable 中的数据到达容量阈值，一般是 4MB，就将他转换成不可变的 immutable_table 即只读不写的 SkipList。后面直接将 immutable_table 数据刷入到磁盘上，就是 level0 的数据了。</p>
<h2 id="SSTable"><a href="#SSTable" class="headerlink" title="SSTable"></a>SSTable</h2><p>SSTable 就是一个按找字符排好序的文件，但是仅仅存储值也是不够的。比如最开始写入了 Key_0，然后系统一直运行，而且后续在也没有插入新的 Key 为 Key_0 的值了，那么内存中肯定是没有数据的，必然会触发到文件中去找的需求。这里就遇到元数据的组织问题，即如何知道当前文件是处于那一层的，当前文件中包含了哪些 Key 值，在前面的 MANIFEST 文件内容中提到过，每一时刻当前的数据库都有一个对应的 Version，记录了当前数据库中每一层有哪些文件。</p>
<p>SSTable 文件写入后是不可变的，所以在合并的时候也是新建一个文件，然后将需要合并的数据合并成一个新的文件，必要的时候可能会将他的层级往下。</p>
<p>因为涉及到合并，Version 管理，不一一详细介绍，会在后面的 Version 和 合并等操作中解析。</p>
<p>总结下就是 SSTable 的文件组织是放在 Version 中，也就是某一时刻，当前的数据库有哪些文件，删除哪些文件等等信息会放在 Version，每次操作都会写入 MANIFEST 文件中。</p>
<p>但是每层的数据大小是不一定的，比如 Level0 层的数据是直接写入的 Mem_table,也即是 4MB，但是 Level1 层的大小是 10MB，而且并不是说一个完整的 10MB 的文件，而是分成 2MB 的文件。除了 Level0 以外的数据都是组织成 2MB 的文件，而且每一层都是上一层的 10 倍大小。</p>
<p>由于文件都需要合并，比如说当前 Level0 层和 Level1 层都是满的而且里面的 Key 各不相同，在合并的过程中可能就是需要读取 10+16MB，然后在写入 10+16 MB 的数据。</p>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>其实在读取的过程中还会涉及到一个 LRUCache，但是个人觉得和总的架构来说只是一个缓存的左右，用于加快查询，所以没有在图上展示出来。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文非常粗糙的介绍了下 LevelDB 的整体结构。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/31/LevelDB%E4%B9%8BSkipList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mingyouxiaozhu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingyouxiaozhu's blog">
      <meta itemprop="description" content="enjoy life ,enjoy coding">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | mingyouxiaozhu's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/31/LevelDB%E4%B9%8BSkipList/" class="post-title-link" itemprop="url">LevelDB之SkipList</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-31 15:56:31" itemprop="dateCreated datePublished" datetime="2023-08-31T15:56:31+08:00">2023-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-04 09:39:11" itemprop="dateModified" datetime="2023-09-04T09:39:11+08:00">2023-09-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在数据结构中，树一直被很多系统钟爱，如 mysql 的 innodb 使用的是 B+ 数，在 java 中 Map 的 hash 碰撞后，如果链表超过 8 会切换为红黑树。树结构的好处个人认为是在写入的时候对数据进行一个预处理，而且这个出力和子节点的数量相关，在写入的时候按照规则插入，能够在查询的时候有效的查询对应的子树，从而达到查询时间为 LogN 。如红黑树，红黑树的结构是异构化的 23 树，能够确保左右子树的高度差维持在 1，有效保证数据平衡，但是红黑树的实现比较复杂，插入过程涉及到树的重平衡。后来出现了一种链表的结构，称之为跳表即 SkipList，他是由 William Pugh 在<a target="_blank" rel="noopener" href="https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf">Skip Lists: A Probabilistic Alternative to Balanced Trees</a>提出的一种平衡性很好的数据结构，这种数据结构是使用空间换时间，实现较为简单，查询复杂度和树结构接近。在 redis 和 leveldb 中都有使用。本文会介绍下 leveldb 中的 SkipList 的实现。</p>
<h2 id="SkipList-原理"><a href="#SkipList-原理" class="headerlink" title="SkipList 原理"></a>SkipList 原理</h2><p>在某种意义上，链表可以算得上是一种特殊的树，只有一个分支的树。一般情况下分为单向链表和双向链表。单向链表里面的节点会有个指针指向下一个节点，双向链表包含两个指针，一个指向指向他的节点（prev），一个指向下一个节点。SkipList 是单向链表，但是不止一个链表，而是使用 n 个链表分层，每一层中的 node 指向的下一个节点各不相同。后续的说明主要是针对上文提到的论文中的一个小摘抄：</p>
<p>论文中提到（第一节），二叉树在随机大小写入的情况下效率很高，但是如果是顺序大小写入则表现的比较一般，这个是因为二叉树尤其是平衡二叉树需要对数结构进行一个平衡引起的。</p>
<p>SkipList 是一种平衡树的概率性的替代品，这里概率性个人觉得主要是上面提到的随机大小数据写入过程平衡树效率比顺序写高，就是通过另外的方式实现了这种顺序写变为随机。论文中提到，250 个元素的 skiplist 需要查询查过 3 次的概率不到百万分之一。</p>
<p>论文中还提到，skiplist 在实现上比较容易，而且使用的是概率性的计算来保持数据的平衡，在空间上平均每个节点可能只需要 1+1&#x2F;3 个指针。</p>
<p>SkipList 还有一个好处就对锁范围的控制上，在平衡二叉树或者红黑树，在并发操作的情况下，特定的时候如需要修改 Root 节点的属性，可能需要对整棵树都加锁。但是 SkipList 里面可以针对局部节点进行加锁，在并发情况下实现比较好。</p>
<p><img src="http://image.mingyouxiaozhu.top/blog/image-20230831163355393.png" alt="image-20230831163355393"></p>
<p>上图选自论文中的 figure1。</p>
<p>n 标识当前链表的长度，且链表是顺序存储的。</p>
<ol>
<li>在初始阶段，当前的单向链表查询可能需要遍历 n</li>
<li>如果将可以记录每间隔个节点创建连接，则可以将查找的时间缩小为 n&#x2F;2+1。按照最上层比较，可以找到当前查询值的前一个节点，所以是 n&#x2F;2+1</li>
<li>还可以在 2 的基础上，每间隔一个继续创建一个连接，则时间缩小为 n&#x2F;4+2。首先最上层找，此时是 n&#x2F;4，然后在第二层，因为当前中间有 b 层，而且 b 层此时只有 1 个节点，当前值要么大于这个值要么小于，所以需要 2 次就可以找到当前值。</li>
<li>现在将具有 k 个指向其他指针的节点称之为 level K 节点，则说明第 2^i 节点后面有 2^i 个节点，则节点分布在一个比较均匀的数据中。level0 0 节点有 100%个节点，有 50% 的节点在 level1,有 25% 在 level2，以此类推。</li>
<li>但是如果我们随机选择 level1 层的节点，可能会出现上图 e 中情况，也就是高层分配不均匀，如 6 虽然在第四层，但是他却处于第二个位置。</li>
</ol>
<p>可以看到，SkipList 的核心其实是这个层数的确定，如果是按照十分恰当的分配节点中的每一个节点的 level，他的时间复杂度就是 logN。</p>
<p>这个上升当前节点的 level 的时机是影响链表查询的关键。</p>
<h3 id="SkipList-的操作"><a href="#SkipList-的操作" class="headerlink" title="SkipList 的操作"></a>SkipList 的操作</h3><p>主要设计到增删查：</p>
<ol>
<li><p>Search 操作返回目标关键字所关联的 value，如果没有该关键字则返回 failure</p>
</li>
<li><p>Insert 操作对目标关键字更新 value，如果目标关键字不存在，则将关键字插入</p>
</li>
<li><p>Delete 操作删除目标关键字。</p>
</li>
</ol>
<h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><p>查询操作是删除和插入的基础，因为每一层都是单向链表，所以必须要找到插入的父节点才行，如果当前节点的 level 较高，可能还需要将查询过程中的每一层的父节点都记录下来。</p>
<p>伪代码如下：（论文 figure2）</p>
<p><img src="http://image.mingyouxiaozhu.top/blog/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16935493045545.png" alt="img"></p>
<p>伪代码是搜索一个 searchKey 是否在 skiplist 中。具体步骤如下：</p>
<ol>
<li>将 x 初始话为 skiplist 的头节点</li>
<li>进入第一次循环，循环是从当前最大的 level 到 level1</li>
<li>然后进入第二层循环，在当前层的 forword 对象中找到 key 值不小于当前 searchkey 的值</li>
<li>跳出 3 的循环后，此时已经找到本层不小于 searchkey 的值，继续往下一层找。如果找到了等于当前 searchkey 的值，则返回值存储的 value。</li>
<li>如果从 maxlevel 到 1 都没有这个值，返回一个 failture。</li>
</ol>
<p>查询就是从最上层往下查询的过程。</p>
<h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><p>在上文中，我们查询不到这个值就返回一个 failture，但是其实也可以返回当前找到的 level1 层的值，因为这个值是当前 skiplist 中不小于 searchKey 的值。如果说是插入，那么也应该是插入到这个值的后面。但是因为涉及到 level 的变化，所以查询过程中需要将当前查到的每一层不小于当前的值都查出来，然后随机一个当前值的 level，然后将存储的每一层 level 都和当前 level 进行一个绑定。删除也类似。</p>
<p>插入和删除图形化为:</p>
<p><img src="http://image.mingyouxiaozhu.top/blog/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16935514661062.png" alt="img"></p>
<p>后文根据论文中的伪代码介绍下操作</p>
<h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>插入的伪代码如下：论文 figure4</p>
<p><img src="http://image.mingyouxiaozhu.top/blog/image-20230901144301435.png" alt="image-20230901144301435"></p>
<ol>
<li><p>定义一个变量 update，用来存储上文提到的每一层中不小于当前值的 Node。</p>
</li>
<li><p>查找当前的 key 和将每一层比较的结果赋值到 update 中。</p>
</li>
<li><p>如果查到当前值了，那么 put 就变成了 update，直接将 skiplist 中的对应 key 的 value 修改为当前的 newvalue。</p>
</li>
<li><p>如果没有找到，也就是上文提到的，首先随机产生一个当前的 level。如果当前的 level 超过 skiplist 当前最大的 level，那么需要将当前的 level 设置为新生成的 level，然后将 head 放到每一层的头节点。</p>
</li>
<li><p>将插入的数据变成 Node，Node 包含了当前 key，value 和 level 信息，当然内部还有个 next 信息</p>
</li>
<li><p>从第 1 层往上，将当前的 x 插入到每一层。</p>
</li>
</ol>
<p>这里有个问题就是对 level 的管理，因为不可能随便随机一个数出来，最好的是希望设置一个 maxlevel，然后作为 seed，在 maxLevel 下面随机产生层数。</p>
<h6 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h6><p>在论文中提到过，skiplist 本身是个概率性的算法，个人觉得概率性其实就是指的层数的选择。他想要达到的效果是在上升中，某一层出现的概率是大致一定的。也就是说如果第 i 层的元素能够按照某个固定的概率 p（上文使用的是 1&#x2F;2）出现在在 i+1 层，这里面涉及到概率论里面期望运算，就不再赘述了（我已经还给老师了）。一句话说就是如过选择的是 p&#x3D;1&#x2F;2，那么我们就希望如果 n 等于 16，那么第 0 层是 16，第二次是 8，第三层是 4。说白了就是返回的值出现的概率是一样的，比如 返回 1 的概率就是 1&#x2F;2，返回 2 的概率就是 1&#x2F;4。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PROBABILITY</span> <span class="operator">=</span> <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">while</span> (random.nextDouble() &lt; PROBABILITY &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用这种方式可以生成，主要是因为 random.nextDouble() 出现的数是比较均匀的分布，就是出现的概率是相对一定的，然后只要小于 0.5 就多一层，也就是上面的 1&#x2F;2 的概率，继续增加 level，则就是 1&#x2F;2 *1&#x2F;2 的概率了。</p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>删除也是在查询基础上做的，伪代码如下：</p>
<p><img src="http://image.mingyouxiaozhu.top/blog/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16935584519268.png" alt="img"></p>
<p>首先仍然是记录下查询过程的每一层的上一个节点，如果找到这个值对应的 Node，就将 update 中存储的值都进行一个链表删除操作，然后释放内存。最后，还需要检查当前是否删除了最高的 level 中的最后一个 node，如果是还需要将当前的 level 减 1.</p>
<h4 id="自己写个-SkipList"><a href="#自己写个-SkipList" class="headerlink" title="自己写个 SkipList"></a>自己写个 SkipList</h4><p>使用 java 自己写了个 skiplist，其中数据使用 DataNode，索引使用 IndexNode，避免值的无效覆盖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkipList</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;</span><br><span class="line">	<span class="comment">// 当前最大的层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxLevel</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">    <span class="comment">// 头结点，down 使用down指向下一层</span></span><br><span class="line">    <span class="keyword">private</span> SkipListIndexNode&lt;K, V&gt; head;</span><br><span class="line">	<span class="comment">// 当前的level</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random;</span><br><span class="line">    <span class="comment">//跳到下一层的概率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">probability</span> <span class="operator">=</span> <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SkipList</span><span class="params">(<span class="type">int</span> maxLevel, <span class="type">double</span> probability)</span> &#123;</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="built_in">this</span>.maxLevel = maxLevel;</span><br><span class="line">        <span class="built_in">this</span>.probability = probability;</span><br><span class="line">        <span class="type">SkipListDataNode</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkipListDataNode</span>(Integer.MIN_VALUE, <span class="literal">null</span>);</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">SkipListIndexNode</span>(data, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        SkipListDataNode&lt;K, V&gt; old = searchNode(key);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> old.value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getMax</span><span class="params">()</span> &#123;</span><br><span class="line">        SkipListIndexNode&lt;K, V&gt; cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.down != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.down == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        SkipListIndexNode&lt;K, V&gt; cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.down != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.right == <span class="literal">null</span> ? <span class="literal">null</span> : cur.right.getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="type">SkipListDataNode</span> <span class="variable">old</span> <span class="operator">=</span> searchNode(key);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">            old.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newLevel</span> <span class="operator">=</span> randomLevel();</span><br><span class="line">        <span class="keyword">if</span>(newLevel&gt;maxLevel)&#123;</span><br><span class="line">            newLevel=maxLevel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newLevel &gt; level ) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> level; i &lt; newLevel; i++) &#123;</span><br><span class="line">                genNewHead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SkipListDataNode&lt;K, V&gt; data = <span class="keyword">new</span> <span class="title class_">SkipListDataNode</span>&lt;K, V&gt;(key, value);</span><br><span class="line">        SkipListIndexNode&lt;K, V&gt; indexNode = <span class="keyword">new</span> <span class="title class_">SkipListIndexNode</span>&lt;K, V&gt;(data, newLevel);</span><br><span class="line">        LinkedList&lt;SkipListIndexNode&gt; update = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;SkipListIndexNode&gt;();</span><br><span class="line">        SkipListIndexNode&lt;K, V&gt; cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.level &gt; newLevel) &#123;</span><br><span class="line">            cur = cur.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur.right != <span class="literal">null</span> &amp;&amp; cur.right.getKey().compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            update.add(cur);</span><br><span class="line">            cur = cur.down;</span><br><span class="line">        &#125;</span><br><span class="line">        SkipListIndexNode&lt;K, V&gt; bottom = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!update.isEmpty()) &#123;</span><br><span class="line">            <span class="type">SkipListIndexNode</span> <span class="variable">prevNode</span> <span class="operator">=</span> update.pollLast();</span><br><span class="line">            <span class="type">SkipListIndexNode</span> <span class="variable">curLevelIndex</span> <span class="operator">=</span> indexNode.genIndexNodeByLevel(prevNode.level);</span><br><span class="line">            curLevelIndex.right = prevNode.right;</span><br><span class="line">            prevNode.right = curLevelIndex;</span><br><span class="line">            curLevelIndex.down = bottom;</span><br><span class="line">            bottom = curLevelIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        LinkedList&lt;SkipListIndexNode&gt; update = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;SkipListIndexNode&gt;();</span><br><span class="line">        SkipListIndexNode&lt;K, V&gt; cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur.right != <span class="literal">null</span> &amp;&amp; cur.right.getKey().compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            update.add(cur);</span><br><span class="line">            cur = cur.down;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!update.isEmpty()) &#123;</span><br><span class="line">            <span class="type">SkipListIndexNode</span> <span class="variable">skipListIndexNode</span> <span class="operator">=</span> update.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (skipListIndexNode.right != <span class="literal">null</span> &amp;&amp; skipListIndexNode.right.getKey().compareTo(key) == <span class="number">0</span>) &#123;</span><br><span class="line">                skipListIndexNode.right = skipListIndexNode.right.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            level--;</span><br><span class="line">            head = head.down;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SkipListIndexNode</span> <span class="variable">bottom</span> <span class="operator">=</span> head;</span><br><span class="line">        LinkedList&lt;SkipListIndexNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;SkipListIndexNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (bottom.down != <span class="literal">null</span>) &#123;</span><br><span class="line">            bottom = bottom.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SkipListIndexNode</span> <span class="variable">printLevel</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (printLevel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">SkipListIndexNode</span> <span class="variable">printLeveltail</span> <span class="operator">=</span> printLevel;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%-5s&quot;</span>, <span class="string">&quot;head-&gt;&quot;</span>);</span><br><span class="line">            <span class="type">SkipListIndexNode</span> <span class="variable">bottomTail</span> <span class="operator">=</span> bottom;</span><br><span class="line">            <span class="keyword">while</span> (printLeveltail != <span class="literal">null</span> &amp;&amp; bottomTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (printLeveltail.right != <span class="literal">null</span> &amp;&amp; printLeveltail.right.getKey().compareTo(bottomTail.right.getKey()) == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%-5s&quot;</span>, printLeveltail.right.getKey() + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                    printLeveltail = printLeveltail.right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%-5s&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                bottomTail = bottomTail.right;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            printLevel = printLevel.down;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SkipListDataNode <span class="title function_">searchNode</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SkipListIndexNode&lt;K, V&gt; cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur.right != <span class="literal">null</span> &amp;&amp; cur.right.getKey().compareTo(key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span> &amp;&amp; cur.right.getKey().compareTo(key) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur.right.dataNode;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.down;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">genNewHead</span><span class="params">()</span> &#123;</span><br><span class="line">        SkipListIndexNode&lt;K, V&gt; skipListIndexNode = <span class="keyword">new</span> <span class="title class_">SkipListIndexNode</span>&lt;K, V&gt;(<span class="literal">null</span>, ++level);</span><br><span class="line">        skipListIndexNode.down = head;</span><br><span class="line">        head = skipListIndexNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (random.nextDouble() &lt; probability &amp;&amp; level &lt; maxLevel) &#123;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SkipList&lt;Integer, Integer&gt; skipList = <span class="keyword">new</span> <span class="title class_">SkipList</span>&lt;Integer, Integer&gt;(<span class="number">12</span>, <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">200</span>; i++) &#123;</span><br><span class="line">            skipList.put(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">200</span>), <span class="number">100</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        skipList.printList();</span><br><span class="line">        ;</span><br><span class="line">        System.out.println(skipList.get(<span class="number">10</span>));</span><br><span class="line">        System.out.println(skipList.get(<span class="number">11</span>));</span><br><span class="line">        System.out.println(skipList.get(<span class="number">12</span>));</span><br><span class="line">        System.out.println(skipList.getMin());</span><br><span class="line">        System.out.println(skipList.getMax());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">20</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            skipList.delete(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(skipList.get(<span class="number">10</span>));</span><br><span class="line">        System.out.println(skipList.get(<span class="number">11</span>));</span><br><span class="line">        System.out.println(skipList.get(<span class="number">12</span>));</span><br><span class="line">        System.out.println(skipList.getMin());</span><br><span class="line">        System.out.println(skipList.getMax());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SkipListDataNode</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">        SkipListDataNode(K key, V value) &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SkipListIndexNode</span>&lt;K <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;K&gt;, V&gt; &#123;</span><br><span class="line">        SkipListDataNode&lt;K, V&gt; dataNode;</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        SkipListIndexNode&lt;K, V&gt; right;</span><br><span class="line">        SkipListIndexNode&lt;K, V&gt; down;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SkipListIndexNode</span><span class="params">(SkipListDataNode&lt;K, V&gt; dataNode, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.dataNode = dataNode;</span><br><span class="line">            <span class="built_in">this</span>.level = level;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> SkipListIndexNode <span class="title function_">genIndexNodeByLevel</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SkipListIndexNode</span>(<span class="built_in">this</span>.dataNode, level);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dataNode.value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> K <span class="title function_">getKey</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dataNode.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="LevelDB-的-SkipList-实现"><a href="#LevelDB-的-SkipList-实现" class="headerlink" title="LevelDB 的 SkipList 实现"></a>LevelDB 的 SkipList 实现</h2><p>在上面已经较为详细的介绍了 SkipList，也使用 java 做了一个简单的实现。下面来看下 LevelDB 中的 SkipList 的实现。</p>
<p>在几乎所有的 SkipList 的方法上面都有一个 template 。这个的作用有点类似于 java 的泛型，只不过 java 是运行时而 C++ 是编译阶段。</p>
<blockquote>
<p>template &lt;typename Key, class Comparator&gt; 值得是一个 key，这个 key 和 Comparator 是一个占位符，用来表示具体传入的数据类型，后面的 Comparator，则说明需要传入一个实现了 Comparator 的接口或者类的类型。</p>
</blockquote>
<h4 id="random-方法"><a href="#random-方法" class="headerlink" title="random 方法"></a>random 方法</h4><p>首先来看下 random 的方法使用的位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="type">int</span> SkipList&lt;Key, Comparator&gt;::RandomHeight() &#123;</span><br><span class="line">  <span class="comment">// Increase height with probability 1 in kBranching</span></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> kBranching = <span class="number">4</span>;</span><br><span class="line">  <span class="type">int</span> height = <span class="number">1</span>; <span class="comment">// 初始level是1</span></span><br><span class="line">  <span class="keyword">while</span> (height &lt; kMaxHeight &amp;&amp; rnd_.OneIn(kBranching)) &#123;<span class="comment">// 根据概率，默认1/4</span></span><br><span class="line">    height++;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(height &gt; <span class="number">0</span>);</span><br><span class="line">  assert(height &lt;= kMaxHeight); <span class="comment">// 当前的level是不是小于kMaxHeight（默认12）</span></span><br><span class="line">  <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中最要的是这个<em>rnd_.OneIn</em> 方法，这个方法就是生成均匀分布的随机数。</p>
<blockquote>
<p>现在的随机算法都是伪随机，算法为线性同余生成器，算法表示为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xn+<span class="number">1</span> = (a * Xn + c) % m</span><br></pre></td></tr></table></figure>

<p>其中，<code>Xn</code> 是当前生成的伪随机数，<code>Xn+1</code> 是下一个生成的伪随机数，<code>a</code> 是乘法因子，<code>c</code> 是增量，<code>m</code> 是模数。通常，<code>a</code> 取 <code>16807</code>，<code>c</code> 取 <code>0</code>，<code>m</code> 取 <code>2147483647</code>，这是因为这组参数在计算中具有良好的性质，可以生成均匀分布的伪随机数。</p>
</blockquote>
<p>在 leveldb 中就使用到了上面提到的两个魔法数，具体是现在在<code>util/random.h</code>，因为是一个整体，所以全部复制出来，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Random</span> &#123;</span></span><br><span class="line"> private:</span><br><span class="line">  <span class="type">uint32_t</span> seed_;</span><br><span class="line"></span><br><span class="line"> public:</span><br><span class="line">  explicit <span class="title function_">Random</span><span class="params">(<span class="type">uint32_t</span> s)</span> : <span class="title function_">seed_</span><span class="params">(s &amp; <span class="number">0x7fffffff</span>u)</span> &#123; <span class="comment">//0x7fffffff u表示无符号 2^31-1 二进制 111 1111 1111 1111 1111 1111 1111 1111 将第一位取0 ，因为无符号转化为有符号的时候头部位1 表示为负数</span></span><br><span class="line">                                                          <span class="comment">// 所以此处的主要目的是确保传入的s为正数，默认传入的seed初始值为0xdeadbeef 二进制为1101 1110 1010 1101 1011 1110 1110 1111</span></span><br><span class="line">    <span class="comment">// Avoid bad seeds.</span></span><br><span class="line">    <span class="keyword">if</span> (seed_ == <span class="number">0</span> || seed_ == <span class="number">2147483647L</span>) &#123;</span><br><span class="line">      seed_ = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint32_t</span> <span class="title function_">Next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> M = <span class="number">2147483647L</span>;  <span class="comment">// 2^31-1</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> A = <span class="number">16807</span>;        <span class="comment">// bits 14, 8, 7, 5, 2, 1, 0 //无符号64位二进制0100 0001 1010 0111</span></span><br><span class="line">    <span class="comment">// We are computing</span></span><br><span class="line">    <span class="comment">//       seed_ = (seed_ * A) % M,    where M = 2^31-1</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// seed_ must not be zero or M, or else all subsequent computed values</span></span><br><span class="line">    <span class="comment">// will be zero or M respectively.  For all other values, seed_ will end</span></span><br><span class="line">    <span class="comment">// up cycling through every number in [1,M-1]</span></span><br><span class="line">    <span class="type">uint64_t</span> product = seed_ * A; <span class="comment">//26696993619177 二进制 High[000000 00000 0000 0000 1100 0010 0011  1] low [111 00000 1101 0010 0011 1100 1110 1001]</span></span><br><span class="line">     <span class="comment">//这里是计算Mod算法的一个优化，一个64为的数，可以分为高33 位和低31 位的数</span></span><br><span class="line">    <span class="comment">// Compute (product % M) using the fact that ((x &lt;&lt; 31) % M) == x. product=high&lt;&lt;31+low 又因为product=seed_*A,所以此时product=(high*M+high+low)%M 其中 M = 2^31-1</span></span><br><span class="line">    <span class="comment">// 因为seed_ 和A 中，seed_的值在初始化的时候就让他小于2^31-1，A 是固定的16807,所以这两个值都不会大于M的值，所以取余最后的结果就等(high+low)%M=high+low,所以下面的这个计算是获取high和low的值相加，也就得到了seed_</span></span><br><span class="line">    <span class="comment">// 但是有一种情况就是product的low为刚好但是 2^31-1，这个时候product=(high*M+high+1*M)%M=high ，但是使用下面的结果会是high+M，因为M&amp;M=M。所以，需要判断是否seed_ 比M大，然后前去M，直接使用high,也确保了seed的值一直小于M</span></span><br><span class="line">    <span class="comment">// 最后强制转换为32位的值</span></span><br><span class="line">    seed_ = static_cast&lt;<span class="type">uint32_t</span>&gt;((product &gt;&gt; <span class="number">31</span>) + (product &amp; M)); <span class="comment">// High+low [000000 00000 0000 0000 1100 0010 0011  1]+[111 00000 1101 0010 0011 1100 1110 1001] &amp; [111 1111 1111 1111 1111 1111 1111 1111]</span></span><br><span class="line">    <span class="comment">// The first reduction may overflow by 1 bit, so we may need to</span></span><br><span class="line">    <span class="comment">// repeat.  mod == M is not possible; using &gt; allows the faster</span></span><br><span class="line">    <span class="comment">// sign-bit-based test.</span></span><br><span class="line">    <span class="keyword">if</span> (seed_ &gt; M) &#123;</span><br><span class="line">      seed_ -= M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seed_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在[0,n-1]之间返回随机数</span></span><br><span class="line">  <span class="comment">// Returns a uniformly distributed value in the range [0..n-1]</span></span><br><span class="line">  <span class="comment">// REQUIRES: n &gt; 0</span></span><br><span class="line">  <span class="type">uint32_t</span> <span class="title function_">Uniform</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="keyword">return</span> Next() % n; &#125;</span><br><span class="line">  <span class="comment">// n分之一的概率返回true</span></span><br><span class="line">  <span class="comment">// Randomly returns true ~&quot;1/n&quot; of the time, and false otherwise.</span></span><br><span class="line">  <span class="comment">// REQUIRES: n &gt; 0</span></span><br><span class="line">  <span class="type">bool</span> <span class="title function_">OneIn</span><span class="params">(<span class="type">int</span> n)</span> &#123; <span class="keyword">return</span> (Next() % n) == <span class="number">0</span>; &#125;</span><br><span class="line">  <span class="comment">// //首先求得[0,max_log]的一个随机数，然后求得[0,2^maxlog-1]的一个随机数</span></span><br><span class="line">  <span class="comment">// Skewed: pick &quot;base&quot; uniformly from range [0,max_log] and then</span></span><br><span class="line">  <span class="comment">// return &quot;base&quot; random bits.  The effect is to pick a number in the</span></span><br><span class="line">  <span class="comment">// range [0,2^max_log-1] with exponential bias towards smaller numbers.</span></span><br><span class="line">  <span class="type">uint32_t</span> <span class="title function_">Skewed</span><span class="params">(<span class="type">int</span> max_log)</span> &#123; <span class="keyword">return</span> Uniform(<span class="number">1</span> &lt;&lt; Uniform(max_log + <span class="number">1</span>)); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法就随机数的 seed 计算比较上头。因为第一个种子确定后，后面的种子都相对确定了，而且这个出现的概率比较均匀，所以也就是 OneIn 能够保证出现概率接近的原因。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>leveldb 中的 SkipList 具体实现在<code>db/skiplist.h</code>中。</p>
<p>私有域：</p>
<ol>
<li>struct Node 用来存储数据，和上面 Java 实现的不同，Node 中 key 的值既包含了需要查询的 key，也包含具体的 Value，这个和数据存储格式相关系</li>
<li>enum { <em>kMaxHeight</em> &#x3D; 12 }; 允许最大的层数是 12 层</li>
<li>compare_ 用来做 key 值比较的比较器</li>
<li>arena_ 为每个 Node 分配内存</li>
<li>head_ 头结点指针</li>
<li>std::atomic<int> max<em>height</em>; 原子递增的最大层数</li>
<li>一个上文提到的随机数生成的对象</li>
</ol>
<blockquote>
<p>explicit 关键字一般用来修饰类的构造函数，作用是告诉编译器按照实际的类型来构造函数，不允许做隐式转换。</p>
</blockquote>
<p>公有域：</p>
<ol>
<li><p>一个不允许隐式转换的构造器</p>
</li>
<li><p>void Insert(const Key&amp; key); &#x2F;&#x2F; 插入方法</p>
</li>
<li><p>bool Contains(const Key&amp; key) const; 判断是否存在</p>
</li>
<li><p>Iterator 一个迭代器实现，迭代器中包含了多种查询方式，包括查找当前的 key 等方法（后文详细介绍）。其中也包含了私有域，指向当前的 SkipList 和一个用来遍历的 Node。</p>
</li>
</ol>
<p>Node 结构体包含了一个 Key，这个就是前面提到的<code>template &lt;typename Key, class Comparator&gt;</code>中的这个 Key，还包含了一个数组</p>
<blockquote>
<p>std::atomic&lt;Node*&gt; next_[1];</p>
</blockquote>
<p>这个是一种柔性的数组。也就是大小是可变的，next 数组是一个指针数组，也就是上文中 java 代码中的 IndexNode，本身不存储 key Value，而是作为索引存储。这个 next 表示当前层数中指向的下一个节点。</p>
<p>一个 SkipList 初始化过程中需要传入的参数就是比较器 comparator* 和内存分配器 arena*的指针。</p>
<h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><p>和上面的实现不同的是，leveldb 的查询是放在 Iterator 的 seek 方法中的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> SkipList&lt;Key, Comparator&gt;::Iterator::Seek(<span class="type">const</span> Key&amp; target) &#123;</span><br><span class="line">  node_ = list_-&gt;FindGreaterOrEqual(target, nullptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后调用的是 SkipList 本身的 FindGreaterOrEqual 方法，也就是要么找到当前值，要么就找到比当前值大的那个值。该方法包含了两个参数，第一个是需要查询的值，第二个是用来存储当前查询 level 的前序节点，也就是 update 数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="type">bool</span> SkipList&lt;Key, Comparator&gt;::KeyIsAfterNode(<span class="type">const</span> Key&amp; key, Node* n) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="comment">// null n is considered infinite</span></span><br><span class="line">  <span class="keyword">return</span> (n != nullptr) &amp;&amp; (compare_(n-&gt;key, key) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(<span class="type">const</span> Key&amp; key,</span><br><span class="line">                                              Node** prev) <span class="type">const</span> &#123;</span><br><span class="line">  Node* x = head_; <span class="comment">// x为后续查询使用的临时数据，此时x在最上层的头结点</span></span><br><span class="line">  <span class="type">int</span> level = GetMaxHeight() - <span class="number">1</span>; <span class="comment">//获取当前最大的层数，从0开始，所以减去1</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Node* next = x-&gt;Next(level); <span class="comment">// next数组就是每一层链表的数据，从head开始</span></span><br><span class="line">    <span class="keyword">if</span> (KeyIsAfterNode(key, next)) &#123; <span class="comment">//找到当前的查询的值是否在x后面，如果是，则说明当前的值的后一个值小于查询的值</span></span><br><span class="line">      <span class="comment">// Keep searching in this list</span></span><br><span class="line">      x = next; <span class="comment">//往右查询。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果x的后面的值大于查询的key，则判断是是否需要记录层数，get中prev是nullptr，所以不需要存储，在insert的时候就需要记录下来</span></span><br><span class="line">      <span class="keyword">if</span> (prev != nullptr) prev[level] = x;</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123; <span class="comment">// 如果当前已经查询到最后一层，则返回这个next，此时next因为前面的KeyIsAfterNode 返回的是false，所以要么当前的值的右边为nullptr要么这个值就比key大，而且是紧挨的着的那个大于这个key的值。仅仅在第0层是这个结果</span></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本身实现上和上文的没有区别，首先从最高层往下便利，其中 Next 方法就是获取到下一层的节点。这个方法还有一个实现就是<code>NoBarrier_Next</code>,两者的区别就是是否允许重排，在 java 中，指令重排是使用 valite 关键字关闭，c++中用下面的方式：（直接使用 leveldb 的代码）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">Next</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  assert(n &gt;= <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span></span><br><span class="line">  <span class="comment">// version of the returned Node.</span></span><br><span class="line">  <span class="keyword">return</span> next_[n].load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SetNext</span><span class="params">(<span class="type">int</span> n, Node* x)</span> &#123;</span><br><span class="line">  assert(n &gt;= <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// Use a &#x27;release store&#x27; so that anybody who reads through this</span></span><br><span class="line">  <span class="comment">// pointer observes a fully initialized version of the inserted node.</span></span><br><span class="line">  next_[n].store(x, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No-barrier variants that can be safely used in a few locations.</span></span><br><span class="line">Node* <span class="title function_">NoBarrier_Next</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">  assert(n &gt;= <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> next_[n].load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">NoBarrier_SetNext</span><span class="params">(<span class="type">int</span> n, Node* x)</span> &#123;</span><br><span class="line">  assert(n &gt;= <span class="number">0</span>);</span><br><span class="line">  next_[n].store(x, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中的 memory_order 就是决定当前的指令是否重排：</p>
<ol>
<li><code>std::memory_order_acquire</code>：这是一种内存顺序语义，用于 <code>load</code> 操作。它确保在加载 <code>next_[n]</code> 指针之前，所有之前的内存操作（写入和读取）都不会被重排序到加载之后。在多线程环境中，这可以确保读取到 <code>next_[n]</code> 的值是最新的。</li>
<li><code>std::memory_order_release</code>：这是一种内存顺序语义，用于 <code>store</code> 操作。它确保在存储 <code>x</code> 到 <code>next_[n]</code> 指针之后，所有之后的内存操作（写入和读取）都不会被重排序到存储之前。在多线程环境中，这可以确保 <code>x</code> 被完全初始化之后再被其他线程访问。</li>
<li><code>std::memory_order_relaxed</code>：这是一种较弱的内存顺序语义，通常用于 <code>load</code> 和 <code>store</code> 操作。它允许更大的重排序自由度，不保证像 <code>acquire</code> 和 <code>release</code> 那样的强制顺序。通常在不需要严格的顺序控制时使用，以提高性能。</li>
</ol>
<p>所以 setNext 值得是当前的获取的 n 是否被后续访问的线程可见，避免了出现多次创建甚至覆盖的问题，但是后面的两个则没有这个限制。</p>
<p>来看个例子：</p>
<p>当前如果有:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">head2---&gt;3-&gt;</span><br><span class="line"></span><br><span class="line">head1---&gt;3-&gt;   5-&gt;   9-&gt;</span><br><span class="line"></span><br><span class="line">head0---&gt;3-&gt;4-&gt;5-&gt;7-&gt;9-&gt;</span><br></pre></td></tr></table></figure>

<p>如果有上文中的 3 层，现在需要查询 8</p>
<ol>
<li>首先 x 被复制为 head2 进入循环，然后 x 获取 head 的链表也就是 next 中的数据，此时为 3</li>
<li>当前查询的 8 大于 3 ，所以将 3 位置 Node 赋值给 x,进入到下次循环</li>
<li>继续获取 3 后面的值，但是此时 3 后面的值为空，所以 KeyIsAfterNode 返回为 false，进入到 else，判断 prev 是否存储，判断是否已经到了第 0 层，此时否为 false，所以将 level–，找下一层</li>
<li>x 此时获取的是 next 中的第 2 层，也就是 head1 后面的 3，因为 3 小于 8，所以找到了 5，所以将 5 赋值给 x，继续循环</li>
<li>此时 x 为 5，里面的 next 指向的是 9，也就是 next 此时为 9，9 大于 8。所以不在赋值给 x。而是进入下一层</li>
<li>进入到 head0，此时 x 为 5，next 为 7，然后 7 小于 8，进入下次循环</li>
<li>此时 x 为 7，但是 next 为 9，因为是 0 层了，所以直接返回 next</li>
</ol>
<p>也就是说这个方法返回的值和他的名字一样，和当前值相等或者比当前值大的第一个数。在 Iterator 中 seek 的值会存储在本身的 node_ 属性中，需要进一步进行判断。如果这个值为 nullptr，则 Iterator 中的 Valid 为 false。</p>
<h5 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h5><p>查询也使用到了上面的 FindGreaterOrEqual</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="type">void</span> SkipList&lt;Key, Comparator&gt;::Insert(<span class="type">const</span> Key&amp; key) &#123;</span><br><span class="line">  <span class="comment">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span></span><br><span class="line">  <span class="comment">// here since Insert() is externally synchronized.</span></span><br><span class="line">  Node* prev[kMaxHeight];</span><br><span class="line">  Node* x = FindGreaterOrEqual(key, prev);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Our data structure does not allow duplicate insertion</span></span><br><span class="line">  assert(x == nullptr || !Equal(key, x-&gt;key));</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> height = RandomHeight();</span><br><span class="line">  <span class="keyword">if</span> (height &gt; GetMaxHeight()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = GetMaxHeight(); i &lt; height; i++) &#123;</span><br><span class="line">      prev[i] = head_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// It is ok to mutate max_height_ without any synchronization</span></span><br><span class="line">    <span class="comment">// with concurrent readers.  A concurrent reader that observes</span></span><br><span class="line">    <span class="comment">// the new value of max_height_ will see either the old value of</span></span><br><span class="line">    <span class="comment">// new level pointers from head_ (nullptr), or a new value set in</span></span><br><span class="line">    <span class="comment">// the loop below.  In the former case the reader will</span></span><br><span class="line">    <span class="comment">// immediately drop to the next level since nullptr sorts after all</span></span><br><span class="line">    <span class="comment">// keys.  In the latter case the reader will use the new node.</span></span><br><span class="line">    max_height_.store(height, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  x = NewNode(key, height);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class="line">    <span class="comment">// we publish a pointer to &quot;x&quot; in prev[i].</span></span><br><span class="line">    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));</span><br><span class="line">    prev[i]-&gt;SetNext(i, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node* SkipList&lt;Key, Comparator&gt;::NewNode(</span><br><span class="line">    <span class="type">const</span> Key&amp; key, <span class="type">int</span> height) &#123;</span><br><span class="line">  <span class="type">char</span>* <span class="type">const</span> node_memory = arena_-&gt;AllocateAligned(</span><br><span class="line">      <span class="keyword">sizeof</span>(Node) + <span class="keyword">sizeof</span>(<span class="built_in">std</span>::atomic&lt;Node*&gt;) * (height - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> new (node_memory) Node(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>插入过程中，首先是找到已经存在的 key，或者这个 key 的后缀节点，需要注意的是这个 key 再 leveldb 中时不允许在一个一模一样的 key 已经存在然后继续插入的。leveldb 中的每次插入都包含了一个序列，所以这个 key 一般不会一样，我能想到的完全一样的情况感觉就是 sequence 的值获取是出现问题，导致一个 key 拥有了相同的 sequence，这个后面再讨论。</p>
<p>然后就是获取到一个随机的高度，如果当前的高度超过了现在最大的高度（random 不会返回超过 12 的高度），就需要将在获取 key 的时候存储的 prev 节点添加上新的 head 节点。然后更新高度。将当前的 key 和 height 封装为一个新的 Node，主要是开辟内存空间。然后就是填充各个层的数据</p>
<h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><p>leveldb 本身的删除就是一个添加墓碑标记的删除，后续文件合并才会真正的删除，所以 Skiplist 中也没有删除。</p>
<h5 id="迭代方式"><a href="#迭代方式" class="headerlink" title="迭代方式"></a>迭代方式</h5><p>SkipList 的迭代器中的方法有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Valid</span><span class="params">()</span> <span class="type">const</span>; <span class="comment">// 查询的结果是否是nullptr</span></span><br><span class="line"><span class="comment">// Advances to the next position.</span></span><br><span class="line"><span class="comment">// REQUIRES: Valid()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">()</span>; <span class="comment">// 找到查询值的后续节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Advances to the previous position.</span></span><br><span class="line"><span class="comment">// REQUIRES: Valid()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Prev</span><span class="params">()</span>;<span class="comment">// 查询值的前序节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Advance to the first entry with a key &gt;= target</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Seek</span><span class="params">(<span class="type">const</span> Key&amp; target)</span>; <span class="comment">// 获取到key&gt;=target的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Position at the first entry in list.</span></span><br><span class="line"><span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeekToFirst</span><span class="params">()</span>; <span class="comment">// 最小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Position at the last entry in list.</span></span><br><span class="line"><span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SeekToLast</span><span class="params">()</span>; <span class="comment">// 最大值</span></span><br></pre></td></tr></table></figure>

<p>其中 Valid 、 Next 和 Seek 已经大概说过了。主要就是一个 Prev，SeekToFirst 和 SeekToLast。</p>
<p>SeekToLast 的方法比较简单，就是从 level 为 0 一直遍历到最最后面。SeekToFirst 实现就是找到第一个，也就是获取 level 0 的第一个值。所以这个两个值可以算得上是获取最大最小值。</p>
<p>Prev 则是找到当前查询值小的最后的一个值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line">typename SkipList&lt;Key, Comparator&gt;::Node*</span><br><span class="line">SkipList&lt;Key, Comparator&gt;::FindLessThan(<span class="type">const</span> Key&amp; key) <span class="type">const</span> &#123;</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="type">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    assert(x == head_ || compare_(x-&gt;key, key) &lt; <span class="number">0</span>);</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="keyword">if</span> (next == nullptr || compare_(next-&gt;key, key) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心实现就是上面的 FindLessThan，可以看到和前面的 FindGreaterOrEqual 类似，FindGreaterOrEqual 已经很详细的说过，这里就不赘述了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>leveldb 的 skiplist 的实现是比较经典的实现。只是里面的获取为什么需要通过 Iterator，而不是直接提供一个 get 方法我不是很理解。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/31/LevelDB%E4%B9%8BSlice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mingyouxiaozhu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingyouxiaozhu's blog">
      <meta itemprop="description" content="enjoy life ,enjoy coding">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | mingyouxiaozhu's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/31/LevelDB%E4%B9%8BSlice/" class="post-title-link" itemprop="url">LevelDB之Slice</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-31 14:07:00" itemprop="dateCreated datePublished" datetime="2023-08-31T14:07:00+08:00">2023-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-01 20:02:24" itemprop="dateModified" datetime="2023-09-01T20:02:24+08:00">2023-09-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>LevelDB中出现最多的对象就是Slice了，他算的上是一个轻量级的string 对象，里面只有两个成员变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* data_;</span><br><span class="line"><span class="type">size_t</span> size_;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>在Slice 中看到一个c++的operator的关键字，这个关键字的作用就是重载运算。比如重载两个数据中的+</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    MyClass(<span class="type">int</span> val) : value(val) &#123;&#125;</span><br><span class="line">    <span class="comment">// Overloading + operator</span></span><br><span class="line">    MyClass operator+(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        MyClass <span class="title function_">result</span><span class="params">(value + other.value)</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果有MyClass + MyClass的操作，就会执行重载里面的方法。如果是下面那种&#x3D;的重载，则相当于重载了赋值&#x3D; 的含义，后面使用default，则表示使用默认的复制函数</p>
<ol start="2">
<li>const 在后面还有const修饰符，成员函数如果被声明为 <code>const</code>，表示这个成员函数是一个不会修改对象状态的函数。也就是说，它不会修改调用该函数的对象的任何成员变量。感觉是不可变量的一样。</li>
</ol>
</blockquote>
<p>他的构造函数为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Slice() : data_(<span class="string">&quot;&quot;</span>), size_(<span class="number">0</span>) &#123;&#125; <span class="comment">//空slice，</span></span><br><span class="line"> <span class="comment">// Create a slice that refers to d[0,n-1].</span></span><br><span class="line"> Slice(<span class="type">const</span> <span class="type">char</span>* d, <span class="type">size_t</span> n) : data_(d), size_(n) &#123;&#125; <span class="comment">// 在d指向的char数组中0到n-1的char的值</span></span><br><span class="line"> <span class="comment">// Create a slice that refers to the contents of &quot;s&quot;</span></span><br><span class="line"> Slice(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s) : data_(s.data()), size_(s.size()) &#123;&#125; <span class="comment">// 传入一个string的地址</span></span><br><span class="line"> <span class="comment">// Create a slice that refers to s[0,strlen(s)-1]</span></span><br><span class="line"> Slice(<span class="type">const</span> <span class="type">char</span>* s) : data_(s), size_(<span class="built_in">strlen</span>(s)) &#123;&#125; <span class="comment">//自传入char的指针</span></span><br><span class="line"> <span class="comment">// Intentionally copyable.</span></span><br><span class="line">Slice(<span class="type">const</span> Slice&amp;) = <span class="keyword">default</span>; </span><br><span class="line">Slice&amp; operator=(<span class="type">const</span> Slice&amp;) = <span class="keyword">default</span>; <span class="comment">// 这种写法就是重载了= 的运算符</span></span><br></pre></td></tr></table></figure>

<p>可以看到，他接受的最后基本上都是一个char的指针，以及当前在char指针中存储的数据length，需要获取数据，就直接去对应的char数组里面获取。本身没有创建内存或者释放内存，也就是说只是做为一个char数组的标识一样，本身不会产生内存和数据。</p>
<p>他的成员函数包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a pointer to the beginning of the referenced data</span></span><br><span class="line"> <span class="type">const</span> <span class="type">char</span>* <span class="title function_">data</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> data_; &#125; <span class="comment">// 返回当前data的指针</span></span><br><span class="line"> <span class="comment">// Return the length (in bytes) of the referenced data</span></span><br><span class="line"> <span class="type">size_t</span> <span class="title function_">size</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> size_; &#125; <span class="comment">// 当前slice表示的数组长度</span></span><br><span class="line"> <span class="comment">// Return true iff the length of the referenced data is zero</span></span><br><span class="line"> <span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> size_ == <span class="number">0</span>; &#125; <span class="comment">// 判断是否为空</span></span><br><span class="line"> <span class="comment">// Return the ith byte in the referenced data.</span></span><br><span class="line"> <span class="comment">// REQUIRES: n &lt; size()</span></span><br><span class="line"> <span class="type">char</span> operator[](<span class="type">size_t</span> n) <span class="type">const</span> &#123; <span class="comment">// 重载[] 运算符，相当于可以让当前的值变成数组？</span></span><br><span class="line">   assert(n &lt; size());</span><br><span class="line">   <span class="keyword">return</span> data_[n];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// Change this slice to refer to an empty array</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123; <span class="comment">// 清理当前的数据</span></span><br><span class="line">   data_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">   size_ = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// Drop the first &quot;n&quot; bytes from this slice.</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">remove_prefix</span><span class="params">(<span class="type">size_t</span> n)</span> &#123; <span class="comment">// char* 后面的数组内存是连续的。在C++中，数组是一块连续的内存区域，而 char* 是一个指向字符（char）的指针，它可以指向数组的起始位置.所以可以直接将指针往后移，将初始位往后移动</span></span><br><span class="line">   assert(n &lt;= size());</span><br><span class="line">   data_ += n;</span><br><span class="line">   size_ -= n;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// Return a string that contains the copy of the referenced data.</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">ToString</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(data_, size_); &#125; <span class="comment">// 转为string</span></span><br><span class="line"> <span class="comment">// Three-way comparison.  Returns value:</span></span><br><span class="line"> <span class="comment">//   &lt;  0 iff &quot;*this&quot; &lt;  &quot;b&quot;,</span></span><br><span class="line"> <span class="comment">//   == 0 iff &quot;*this&quot; == &quot;b&quot;,</span></span><br><span class="line"> <span class="comment">//   &gt;  0 iff &quot;*this&quot; &gt;  &quot;b&quot;</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> Slice&amp; b)</span> <span class="type">const</span>; <span class="comment">// 和b进行比较</span></span><br><span class="line"> <span class="comment">// Return true iff &quot;x&quot; is a prefix of &quot;*this&quot;</span></span><br><span class="line"> <span class="type">bool</span> <span class="title function_">starts_with</span><span class="params">(<span class="type">const</span> Slice&amp; x)</span> <span class="type">const</span> &#123; <span class="comment">// 前缀判断</span></span><br><span class="line">   <span class="keyword">return</span> ((size_ &gt;= x.size_) &amp;&amp; (<span class="built_in">memcmp</span>(data_, x.data_, x.size_) == <span class="number">0</span>));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>slice的方法除了remove_prefix和clear以外都是非静态的即对Slice本身不做改变，所以在<code>Slice.h</code>中作者写道</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Multiple threads can invoke const methods on a Slice without</span><br><span class="line">// external synchronization, but if any of the threads may call a</span><br><span class="line">// non-const method, all threads accessing the same Slice must use</span><br><span class="line">// external synchronization.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>也就是说只要没有调用非const方法，那么Slice 就是线程安全的。</p>
<p>Slice还有3个内联函数</p>
<blockquote>
<ol>
<li><p>内联方法是会将这个方法在编译阶段直接展开的方法，而不是需要方法调用</p>
</li>
<li><p><code>memcmp</code> 是 C&#x2F;C++ 标准库中的一个函数，用于比较两块内存区域的内容是否相等。它的声明如下：</p>
<p>int memcmp(const void* ptr1, const void* ptr2, size_t num);</p>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> operator==(<span class="type">const</span> Slice&amp; x, <span class="type">const</span> Slice&amp; y) &#123; <span class="comment">// 重载== 方法</span></span><br><span class="line">  <span class="keyword">return</span> ((x.size() == y.size()) &amp;&amp;</span><br><span class="line">          (<span class="built_in">memcmp</span>(x.data(), y.data(), x.size()) == <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> operator!=(<span class="type">const</span> Slice&amp; x, <span class="type">const</span> Slice&amp; y) &#123; <span class="keyword">return</span> !(x == y); &#125; <span class="comment">// 重载 !=</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">Slice::compare</span><span class="params">(<span class="type">const</span> Slice&amp; b)</span> <span class="type">const</span>  <span class="comment">// 和b进行比较,比较两者长度相同位置的char 是否相等</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> min_len = (size_ &lt; b.size_) ? size_ : b.size_; </span><br><span class="line">  <span class="type">int</span> r = <span class="built_in">memcmp</span>(data_, b.data_, min_len);</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size_ &lt; b.size_)</span><br><span class="line">      r = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size_ &gt; b.size_)</span><br><span class="line">      r = +<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="why"><a href="#why" class="headerlink" title="why"></a>why</h2><p>为什么不使用string对象，而是使用Slice 作为char数组呢？在代码中的doc&#x2F;index.md 中说明了原因：</p>
<blockquote>
<p>Returning a Slice is a cheaper alternative to returning a <code>std::string</code> since we do not need to copy potentially large keys and values. In addition, leveldb methods do not return null-terminated C-style strings since leveldb keys and values are allowed to contain <code>&#39;\0&#39;</code> bytes.</p>
</blockquote>
<ol>
<li><p>Slice 本身是不包含内存管理和分配的，而是直接应用外部的char数组指针，这样在操作的时候就避免了数据的复制和拷贝。主要是因为存储格式是按照length value的形势紧凑的存储的，如果key或者value的值较大，可能就是会从原始数据中截断，然后复制到string中，添加了额外的数据复制。</p>
</li>
<li><p>使用Slice 还有一个好处就是上文一直提到的，它本身不管理内存，只是对引用的数据，优化了内存的使用。</p>
</li>
<li><p>数据更加灵活，因为string本身是按照‘\0’作为结束符，但是在LevelDB中可能存在空的字节，这个是因为sequence等高位为空的情况，所以不太适合于string。PS：在debug的过程中，尤其是debug到skiplist插入的时候，就可能存在只能在clion中看到key，但是无法看到value的情况。就是因为string已经被截断了。</p>
</li>
<li><p>和string的切换十分方便，因为构造函数和tostring其实都是将size和data中的数据进行一个转换，能够灵活转换，而且更加灵活记录数据。</p>
</li>
</ol>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Slice 其实就是一个仅记录char 数组头部指针和长度的数据类型，本身可以说不存储数据，个人感觉就是个start，end的结构来记录char 数组中的数据，然后就是提供了需要使用的比较和赋值等数据的方法。因为没有内存，但是可以灵活操作数组中的数据，这里的操作大部分都是线程安全的如比较或者获取的操作。写的操作较少。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/30/LevelDB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mingyouxiaozhu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingyouxiaozhu's blog">
      <meta itemprop="description" content="enjoy life ,enjoy coding">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | mingyouxiaozhu's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/30/LevelDB%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">LevelDB源码学习之内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-30 21:21:50" itemprop="dateCreated datePublished" datetime="2023-08-30T21:21:50+08:00">2023-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-04 09:37:15" itemprop="dateModified" datetime="2023-09-04T09:37:15+08:00">2023-09-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>LevelDB的内存管理相对而言较为简单</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/30/levelDB%E4%B9%8Bcoding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mingyouxiaozhu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingyouxiaozhu's blog">
      <meta itemprop="description" content="enjoy life ,enjoy coding">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | mingyouxiaozhu's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/30/levelDB%E4%B9%8Bcoding/" class="post-title-link" itemprop="url">levelDB之Varint</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-30 10:53:59" itemprop="dateCreated datePublished" datetime="2023-08-30T10:53:59+08:00">2023-08-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-04 09:37:15" itemprop="dateModified" datetime="2023-09-04T09:37:15+08:00">2023-09-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Leveldb 作为一个 kv 数据库，使用的 lsm-tree，一句话解释 lsm-tree 就是将数据按照字符排序。首先将数据写入内存，然后将数据刷入磁盘，定时合并文件。在每个文件头部记录下当前最小最大的 key，然后使用 bloom 记录是否存在 key，查询的时候根据二分查找等方式进行数据查找。<br>数据是紧凑的写在内存或磁盘上的，所以每条数据都会记录当前值的长度和具体的值形如：[key_length][key][value_length][value]，如 key 为 key_123,value 为 value_123,记录方式就是[7][key_123][9][value_123]。一个 32 位整型的空间一般是 4 个字节，Leveldb 就是觉得这个 4 个字节实在是太多了，如上文，当前的 key 是 7，其实只需要一个字节就可以表示，所以在这个上面 Leveldb 使用了 Varint。具体在<code>leveldb/util/coding.cc</code>和<code>leveldb/util/coding.h</code>中实现，本文就是对其中的实现做一个简单的介绍和分析。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>Leveldb 中上文提到的两个源码文件中，包含了两种，一种是 Varint 和 Fixed，包含了 32 位和 64 位，也就是 32 位整型和 64 位整型 的值。核心都是使用 char 数组来表示 32 位整型和 64 位整型。</p>
<h4 id="编码具体实现"><a href="#编码具体实现" class="headerlink" title="编码具体实现"></a>编码具体实现</h4><p>下面是编码方法列表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">EncodeVarint32</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint32_t</span> value)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">EncodeVarint64</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint64_t</span> value)</span>;</span><br><span class="line"><span class="comment">// 在coding.h 文件中直接实现的内联函数</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">EncodeFixed32</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint32_t</span> value)</span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">EncodeFixed64</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint64_t</span> value)</span>;</span><br></pre></td></tr></table></figure>

<p>为了将 32 位整型或者 64 位整型 使用 char 数据记录，肯定需要对 int 的 4 位字节分别存储，也就是每次移动 8 位，为了标识当前字节处于整个字节的位置，还需要预留一个标识符，所以每一个 char 最多有 7 位标识一个 int，2 的 7 次方，也就是一个 char 最多标识 128 的数据。也就是说如果超过了 2 的 28 次方，可能需要额外的字节来标识。也就是说 int 值最多需要 5 个字节来表示。对应的 64 位整型类型则需要使用 64&#x2F;7 +1 也就是 10 个字节来标识。</p>
<h5 id="32-位整型"><a href="#32-位整型" class="headerlink" title="32 位整型"></a>32 位整型</h5><p>下面的代码核心其实就是分为 5 个字节如何存储，每一个 if 就是一个多出一个字节。</p>
<blockquote>
<p>*(ptr++) &#x3D; v;的写法结果：</p>
<ol>
<li>从 <code>ptr</code> 指向的地址获取一个指向的值。</li>
<li>将变量 <code>v</code> 的值赋给该地址处。</li>
<li>将 <code>ptr</code> 的值增加 1，使其指向下一个地址。</li>
</ol>
</blockquote>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">char* EncodeVarint32(char* dst, uint32_t v) &#123;</span><br><span class="line">  // Operate on characters as unsigneds</span><br><span class="line">  uint8_t* ptr = reinterpret_cast&lt;uint8_t*&gt;(dst);// 将当前指针变成uint8_t类型的指针</span><br><span class="line">  static const int B = 128; // 2的 七次方，确1000 0000</span><br><span class="line">  if (v &lt; (1 &lt;&lt; 7)) &#123;</span><br><span class="line">    *(ptr++) = v; // 如果当前的值小于2^7，则直接将值写入指针，最大标识0111 1111 即127</span><br><span class="line">  &#125; else if (v &lt; (1 &lt;&lt; 14)) &#123;</span><br><span class="line">    *(ptr++) = v | B; // 如果值大于2^7，小于2^14，则首先小后七位写入第一个字节，也就是说是小端存储，此时该字节首位是1，因为B 1000 0000  使用或的关系只是将后七位和原值相等，首位赋值1</span><br><span class="line">    *(ptr++) = v &gt;&gt; 7; // 将剩下的值写入，此时首位为0</span><br><span class="line">  &#125; else if (v &lt; (1 &lt;&lt; 21)) &#123; // 大于2^14小于2^21,和上文类似</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; 7) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; 14;</span><br><span class="line">  &#125; else if (v &lt; (1 &lt;&lt; 28)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; 7) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; 14) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; 21;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; 7) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; 14) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; 21) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; 28;</span><br><span class="line">  &#125;</span><br><span class="line">  return reinterpret_cast&lt;char*&gt;(ptr); // 将值转换会原来的位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例说明下面的各个字节标识：</p>
<table>
<thead>
<tr>
<th align="center">原始值</th>
<th align="center">32 位二进制</th>
<th align="center">转换后</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">00000000 00000000 00000000 00000001</td>
<td align="center">00000001</td>
</tr>
<tr>
<td align="center">129</td>
<td align="center">00000000 00000000 00000000 10000001</td>
<td align="center">10000001 00000001</td>
</tr>
<tr>
<td align="center">65537</td>
<td align="center">00000000 00000001 00000000 00000001</td>
<td align="center">10000001 10000000 00000100</td>
</tr>
</tbody></table>
<p>上面分别为 1，2^7+1 ，2^16+1,也就是分别需要 1 字节，2 字节和 3 字节的数据存储。所以 varint32 的值有以下特征：</p>
<ul>
<li>小端存储</li>
<li>如果当前 char 的最高位是 1 ，则说明当前的值没有结束，一直到最高位为 0 的 char</li>
</ul>
<h5 id="64-位整形"><a href="#64-位整形" class="headerlink" title="64 位整形"></a>64 位整形</h5><p>64 位和 32 位基本上没有区别：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">EncodeVarint64</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint64_t</span> v)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="type">uint8_t</span>* ptr = reinterpret_cast&lt;<span class="type">uint8_t</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">while</span> (v &gt;= B) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *(ptr++) = static_cast&lt;<span class="type">uint8_t</span>&gt;(v);</span><br><span class="line">  <span class="keyword">return</span> reinterpret_cast&lt;<span class="type">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现上只是使用循环的方式，其他的都是一样的。这里就不赘述了。</p>
<h4 id="解码具体实现"><a href="#解码具体实现" class="headerlink" title="解码具体实现"></a>解码具体实现</h4><p>相对编码，解码里面提供了较为多方法，包含了和类外一个 LevelDB 比较重要的对象 Slice 的交互，这里先不看这个 Slice 的交互，只看解码的部分。</p>
<p>下面是我觉得两个比较核心的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pointer-based variants of GetVarint...  These either store a value</span></span><br><span class="line"><span class="comment">// in *v and return a pointer just past the parsed value, or return</span></span><br><span class="line"><span class="comment">// nullptr on error.  These routines only look at bytes in the range</span></span><br><span class="line"><span class="comment">// [p..limit-1]</span></span><br><span class="line"><span class="comment">// 传入的待解码char开始指针p,待解码char结束指针，最后值写入的指针v。看方法参数可以看到，一般情况下都是在某个char* 类型的数据上进行顺序读取来获取数据，也就是p 和limit 应该是属于一个char* 的不同位置的指针，他的返回值是指向当前值结尾指针的下一个指针。如果出错，则返回nullptr</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">GetVarint32Ptr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">const</span> <span class="type">char</span>* limit, <span class="type">uint32_t</span>* v)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">GetVarint64Ptr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">const</span> <span class="type">char</span>* limit, <span class="type">uint64_t</span>* v)</span>;</span><br></pre></td></tr></table></figure>

<p>在实现上分为两种情况：</p>
<ol>
<li><p>当前的值小于 128，即传入的 p 的第一个字节为 0，也就是上文编码中说的，如果首位为 0 ，则说明后续都没有数据了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span>* <span class="title function_">GetVarint32Ptr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">const</span> <span class="type">char</span>* limit,</span></span><br><span class="line"><span class="params">                                  <span class="type">uint32_t</span>* value)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (p &lt; limit) &#123; <span class="comment">//确保p是在limit 前面的</span></span><br><span class="line">    <span class="type">uint32_t</span> result = *(reinterpret_cast&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(p));</span><br><span class="line">    <span class="keyword">if</span> ((result &amp; <span class="number">128</span>) == <span class="number">0</span>) &#123; <span class="comment">// p的第一个字节为0，说明当前值7位就可以标识，字节返回。</span></span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> p + <span class="number">1</span>; <span class="comment">// 返回当前解码后值的后一个字节</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> GetVarint32PtrFallback(p, limit, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果超过 7 位，则进入到 GetVarint32PtrFallback 方法中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">GetVarint32PtrFallback</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">const</span> <span class="type">char</span>* limit,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint32_t</span>* value)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最多执行5次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">28</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> byte = *(reinterpret_cast&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(p));</span><br><span class="line">    p++; <span class="comment">// 移动p的指针</span></span><br><span class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) &#123; <span class="comment">// 如果当前char的首位是1，说明后续还有值</span></span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">        <span class="comment">// 取当前值的后7位，并且移动shift</span></span><br><span class="line">      result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当前已经到尾部字节，将值写入即可</span></span><br><span class="line">      result |= (byte &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> reinterpret_cast&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 出现如limit&gt;p这种情况，字节返回nullptr</span></span><br><span class="line">  <span class="keyword">return</span> nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>64 位的解码基本上和 32 位一样，只是移动次数变成了 10 次</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">GetVarint64Ptr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">const</span> <span class="type">char</span>* limit, <span class="type">uint64_t</span>* value)</span> &#123;</span><br><span class="line">  <span class="type">uint64_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">63</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> byte = *(reinterpret_cast&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) &#123;</span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result |= (byte &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> reinterpret_cast&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>leveldb 针对 32 位和 64 位的整形进行了优化，能够节约空间。个人觉得这么做的主要目的是因为我们的 key 或者 value 的值长度一般不会很大，很少人会使用 2^32 个字节来作为 key 存储。所以这么做积少成多，确实能够节约不少的空间。使用 0,1 判断是否到数据尾部，确实很秀。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/24/levelDB-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mingyouxiaozhu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingyouxiaozhu's blog">
      <meta itemprop="description" content="enjoy life ,enjoy coding">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | mingyouxiaozhu's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/24/levelDB-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">levelDB 源码解析之debug环境和数据写入</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-24 21:20:12" itemprop="dateCreated datePublished" datetime="2023-08-24T21:20:12+08:00">2023-08-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-04 09:37:15" itemprop="dateModified" datetime="2023-09-04T09:37:15+08:00">2023-09-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>leveldb 是google的大佬写的一个嵌入式的KV数据库。底层是使用的LSM-Tree 索引结构。本文主要涉及levelDB的数据写入，也就是Put 操作。我是个搞java的，C或者C++是不咋会，所以边看边学，可能比较啰嗦。</p>
<h2 id="Debug环境搭建"><a href="#Debug环境搭建" class="headerlink" title="Debug环境搭建"></a>Debug环境搭建</h2><p>首先拉代码：</p>
<blockquote>
<p>git clone <a target="_blank" rel="noopener" href="https://github.com/google/leveldb.git">https://github.com/google/leveldb.git</a></p>
</blockquote>
<p>因为源码中的third_party  包含了两个，一个是google的test，还有一个是benchmark。需要拉下来，放到third_party的目录，或者直接在目录里pull</p>
<blockquote>
<p>git clone <a target="_blank" rel="noopener" href="https://github.com/google/benchmark.git">https://github.com/google/benchmark.git</a><br>git clone <a target="_blank" rel="noopener" href="https://github.com/google/googletest.git">https://github.com/google/googletest.git</a></p>
</blockquote>
<p>按照文档中，需要</p>
<blockquote>
<p>mkdir -p build &amp;&amp; cd build<br>cmake -DCMAKE_BUILD_TYPE&#x3D;Release .. &amp;&amp; cmake –build .</p>
</blockquote>
<p>但是因为我的目的是在clion debug。所以暂时没有做这一步，而是在源码中新增了一个app目录，下面放我的demo代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/leveldb/db.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  leveldb::DB *db;</span><br><span class="line">  leveldb::Options options;</span><br><span class="line">  options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">  leveldb::Status status = leveldb::DB::Open(options, <span class="string">&quot;/home/tuitaking/source/leveldb/file&quot;</span>, &amp;db);</span><br><span class="line">  assert(status.ok());</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;leveldb open success!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> value;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> key1 = <span class="string">&quot;testkey1&quot;</span>;</span><br><span class="line">  leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);</span><br><span class="line">  <span class="keyword">if</span> (s.IsNotFound()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;can not found for key:&quot;</span> &lt;&lt; key1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    db-&gt;Put(leveldb::WriteOptions(), key1, <span class="string">&quot;testvalue1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;found key:&quot;</span> &lt;&lt; key1 &lt;&lt; <span class="string">&quot;,value:&quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s = db-&gt;Delete(leveldb::WriteOptions(), key1);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;delete key success which key:&quot;</span> &lt;&lt; key1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);</span><br><span class="line">  <span class="keyword">if</span> (s.IsNotFound()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;can not found after delete for key:&quot;</span> &lt;&lt; key1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  delete db;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在CMakeLists.txt 中新增上这个模块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_library(leveldb <span class="string">&quot;&quot;</span> )</span><br><span class="line">target_sources(leveldb</span><br><span class="line">  PRIVATE</span><br><span class="line">    <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/$&#123;LEVELDB_PORT_CONFIG_DIR&#125;/port_config.h&quot;</span></span><br><span class="line">    <span class="string">&quot;app/main.cpp&quot;</span>     # 加这个位置</span><br><span class="line">    <span class="string">&quot;db/builder.cc&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后将test 也加入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leveldb_test(<span class="string">&quot;db/c_test.c&quot;</span>)</span><br><span class="line">leveldb_test(<span class="string">&quot;app/main.cpp&quot;</span>) # 加的这行</span><br></pre></td></tr></table></figure>

<p>然后就可以在clion中看到一个叫main的test，直接可以debug。至于为什么估计需要看cmake 相关的知识，暂时不去管他，总之这样就可以直接debug了。如果是windows，cmake的环境只要做好了，其他的都是类似。在clion中可以直接debug。</p>
<h2 id="数据的写入"><a href="#数据的写入" class="headerlink" title="数据的写入"></a>数据的写入</h2><p>本文暂时不去处理DB的初始化，而是 看PUT操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db-&gt;Put(leveldb::WriteOptions(), key1, <span class="string">&quot;testvalue1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>其中，writeOptions 标识此时是一个写入操作，写入的key就是key1，值就是testvalue1。写入的options 参数只有一个，就是是否sync。也就是写入pagecache  就返回还是刷到磁盘才返回，后者肯定速度慢一点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">DB::Put</span><span class="params">(<span class="type">const</span> WriteOptions&amp; opt, <span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span><br></pre></td></tr></table></figure>

<p>put 的入参为WriteOptions，Slice ，可以看到我们传入的string在这里变成了slice，感觉是c++ 的一个优化还是啥，因为Slice 中有 <code>Slice(const std::string&amp; s)</code> 这样的构造函数，回过来，Slice 可以看做一个变长的而且可以做比较的字符串，使用的是一个<code>c const char* data_; size_t size_;</code>来表示的。然后put操作会将当前传入的值变成一个<code>WriteBatch</code>。</p>
<p>WriteBatch 包含了两个成员变量和六个函数：</p>
<ul>
<li><p>friend class WriteBatchInternal;</p>
<ul>
<li>friend 是一个C++的关键字，表示这个类可以访问私有成员变量</li>
<li>这个对象没有成员变量，全部都是成员函数，用来操作WriteBatch 中的req</li>
</ul>
</li>
<li><p>std::string rep_; </p>
<ul>
<li><p>写入的数据就放入到这个string中 在 write_batch.cc 中有标识：</p>
<ul>
<li><p>WriteBatch::rep_ :&#x3D;<br>  sequence: fixed64  &#x2F;&#x2F; 表示当前写入的seq，每一个写入都有一个seq，用来做类似于mvvc的版本控制的（？）<br>  count: fixed32  &#x2F;&#x2F; 当前bacth中写入的个数<br>  data: record[count] &#x2F;&#x2F;  写入的值，按照keylen+keyValue+dataLen+dataValue</p>
<p>[ sequence: fixed64 ][ count: fixed32 ][ record[0] ][ record[1] ]…[ record[count-1] ]</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Put方法首先就是将key和value放入到writebatch的req中，也就是上文中的data中的值。数据组织完毕。此时的req 的值为</p>
<blockquote>
<p>“\000\000\000\000\000\000\000\000\001\000\000\000\001\008testkey0\004aaaa”   </p>
</blockquote>
<p>在正式写入的方法中</p>
<blockquote>
<p>Status DBImpl::Write(const WriteOptions&amp; options, WriteBatch* updates) </p>
</blockquote>
<p>包含了下面几个操作：</p>
<ol>
<li>将Put操作封装为Writer，并且放到writers 队列中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Writer <span class="title function_">w</span><span class="params">(&amp;mutex_)</span>; </span><br><span class="line">w.batch = updates;</span><br><span class="line">w.sync = options.sync;</span><br><span class="line">w.done = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">MutexLock <span class="title function_">l</span><span class="params">(&amp;mutex_)</span>;</span><br><span class="line"><span class="comment">// 放入队列中  std::deque&lt;Writer*&gt; writers_</span></span><br><span class="line">writers_.push_back(&amp;w);</span><br><span class="line"><span class="comment">// 如果当前的队列不是在头部，则等待。这里就可以控制写入是先来后到的顺序。因为push_back 是加锁的操作，而   且在push之前就已经加锁了。</span></span><br><span class="line"><span class="keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.front()) &#123;</span><br><span class="line">  w.cv.Wait();</span><br><span class="line">   <span class="comment">// 等待</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查下是否已经完成写入，因为下面会有个合并当前写入的操作</span></span><br><span class="line"><span class="keyword">if</span> (w.done) &#123;</span><br><span class="line">  <span class="keyword">return</span> w.status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>上文的代码片段是将写入操作放入队列中,感觉就是和java的线程池中的Runnable 队列一样，将需要执行的work放在队列中。下面是写入前的一些操作：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// May temporarily unlock and wait.</span></span><br><span class="line">  Status status = MakeRoomForWrite(updates == nullptr); <span class="comment">// 确保当前的资源可以使用，涉及到mem和log，暂时不说明，主要就是为本次写入做资源的准备</span></span><br><span class="line">  <span class="type">uint64_t</span> last_sequence = versions_-&gt;LastSequence();<span class="comment">// 从version中获取当前最后的seq</span></span><br><span class="line">  Writer* last_writer = &amp;w;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建完空间和获取到seq，就开始执行写入操作</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; updates != nullptr) &#123;  <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">   WriteBatch* write_batch = BuildBatchGroup(&amp;last_writer); <span class="comment">// 这里就是上文提到的，将此时队列中的write 合并为一个，一起写入</span></span><br><span class="line">    <span class="comment">// 将本次写入的seq 写入到batch中</span></span><br><span class="line">   WriteBatchInternal::SetSequence(write_batch, last_sequence + <span class="number">1</span>);</span><br><span class="line">   last_sequence += WriteBatchInternal::Count(write_batch);</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="comment">// 注释A  </span></span><br><span class="line">   <span class="comment">// Add to log and apply to memtable.  We can release the lock</span></span><br><span class="line">   <span class="comment">// during this phase since &amp;w is currently responsible for logging</span></span><br><span class="line">   <span class="comment">// and protects against concurrent loggers and concurrent writes</span></span><br><span class="line">   <span class="comment">// into mem_. </span></span><br><span class="line">     mutex_.Unlock(); <span class="comment">//释放掉了写入queue中的</span></span><br><span class="line">       <span class="comment">// 写入到日志中</span></span><br><span class="line">     status = log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));</span><br><span class="line">     <span class="type">bool</span> sync_error = <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">if</span> (status.ok() &amp;&amp; options.sync) &#123; <span class="comment">// 如果需要立即刷盘，就将数据刷盘</span></span><br><span class="line">       status = logfile_-&gt;Sync();</span><br><span class="line">       <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">         sync_error = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="comment">// 写入到内存中</span></span><br><span class="line">     <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">       status = WriteBatchInternal::InsertInto(write_batch, mem_);</span><br><span class="line">     &#125;</span><br><span class="line">     mutex_.Lock();</span><br><span class="line">     <span class="keyword">if</span> (sync_error) &#123;</span><br><span class="line">       RecordBackgroundError(status);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (write_batch == tmp_batch_) tmp_batch_-&gt;Clear();</span><br><span class="line"><span class="comment">// 虽然本次是一次写入，但是每次写的seq 都是新增在seq中的，所以seq 应该是一个递增的值</span></span><br><span class="line">   versions_-&gt;SetLastSequence(last_sequence);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 考虑下当前的场景，如果开始有t1,t2,t3 同时写入，此时t1 在writes的front，所以他可以执行上文3 中的代码，也就是将数据写入到log和mem，但是此时writers的front仍然是t1，所以在将队列中所有数据（BuildBatchGroup 会将当前队列中的数据全部变成一个batch）准备好后，如果此时t4,t5,t6线程进行并发写入，他们也会在上文2的代码中被新增到队列尾部，但是不会进入到写操作中，但是由于此时我们的writes的add操作也是被加锁了，所以t4,t5,t6应该是可以加到队列中，但是因为他们都不是front，所以都会在等待，一直到front变成他们中的某一个。</p>
<p>等到当前队列中的数据都写入到日志和内存中后，这个时候会再次获取到锁，判断当前的写入是否出现异常，然后释放当前写入的资源，也就是tmp_batch （BuildBatchGroup）核心就是将写入封装为这个tmp_batch。这里的异常主要是判断是否磁盘有异常，如果有就直接将后续所有的写入全部唤醒为异常状态。清理动作做完后就将sequence进行修改。可以看到sequence的获取和修改都是在加锁的状态下完成的。</p>
<ol start="4">
<li>当前新写入成功后，就可以释放后续的写入线程了</li>
</ol>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  Writer* ready = writers_.front();</span><br><span class="line">  writers_.pop_front();</span><br><span class="line">  <span class="keyword">if</span> (ready != &amp;w) &#123;</span><br><span class="line">    ready-&gt;status = status;</span><br><span class="line">    ready-&gt;done = <span class="literal">true</span>;</span><br><span class="line">    ready-&gt;cv.Signal();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ready == last_writer) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// Notify new head of write queue</span></span><br><span class="line"><span class="keyword">if</span> (!writers_.empty()) &#123;</span><br><span class="line">  writers_.front()-&gt;cv.Signal();</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">return</span> status;</span><br></pre></td></tr></table></figure>

<p>   这里的唤醒核心就是将writers的队列，这个last_writer 指向的就是上文中已经被写入的最后一个writer，也就是说会挨个唤醒和pop出队列，一直到当前写入批次的最后一个。</p>
<p>   如果writers 不为空，则继续唤醒队头，执行上面的操作。</p>
<blockquote>
<p>通过将数据的写入进行入队控制写入的顺序，然后将队列中的当前大小（通过锁确定合并写入队列不持续增加）进行合并写入，然后写入日志和内存，最后挨个唤醒。一个锁做到了控制队列，合并写入等功能。</p>
</blockquote>
<h3 id="写入日志"><a href="#写入日志" class="headerlink" title="写入日志"></a>写入日志</h3><p>写入日志也就是上文的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));</span><br></pre></td></tr></table></figure>










      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/15/kafka%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mingyouxiaozhu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingyouxiaozhu's blog">
      <meta itemprop="description" content="enjoy life ,enjoy coding">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | mingyouxiaozhu's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/15/kafka%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">kafka解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-15 22:29:46" itemprop="dateCreated datePublished" datetime="2023-08-15T22:29:46+08:00">2023-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-25 13:57:17" itemprop="dateModified" datetime="2023-08-25T13:57:17+08:00">2023-08-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面大概说了下kafka的网络模型，还是想将kafka的解析做一个系列。我不是一个很会写故事的人，有时候感觉是意识流。所以这次主要是按照kafka的文档中的<a target="_blank" rel="noopener" href="https://kafka.apache.org/32/documentation.html#design">design</a>,中文翻译<a target="_blank" rel="noopener" href="https://www.oschina.net/translate/kafka-design">地址</a>。按照这个设计需要考虑的进行分析。我写这个的时候刚好是kafka实现了自己的raft，基于的版本是3.3.1</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/08/15/kafka%E8%A7%A3%E6%9E%90/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/14/kafka%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mingyouxiaozhu">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingyouxiaozhu's blog">
      <meta itemprop="description" content="enjoy life ,enjoy coding">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | mingyouxiaozhu's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/14/kafka%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">kafka的网络模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-14 14:27:15" itemprop="dateCreated datePublished" datetime="2023-08-14T14:27:15+08:00">2023-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-08-15 16:28:52" itemprop="dateModified" datetime="2023-08-15T16:28:52+08:00">2023-08-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Kafka 是一个高性能的消息队列。在有 Netty 这么成熟的网络扩建之后，kafka 的客户端和服务端都没有使用 netty 作为网络框架，而是自己完全实现了一个网络层的通信。我能找到的的<a target="_blank" rel="noopener" href="https://www.quora.com/Why-did-Kafka-developers-prefer-to-implement-their-own-socket-server-instead-of-using-Netty-Does-that-help-with-performance-Does-Kafka-implement-such-features-already">原因</a>上面说 1 是为了更好的性能 2 是因为 kafka 本身引用了各种各样的 jar 包，而这些 jar 包很容易引起冲突，而且网络库是比较底层的库，所以才自己实现了一套。本文就 broker 端的 kafka 网络架构做一个大概的解析。希望能够了解到和 netty 实现的区别以及这么带来的好处。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/08/14/kafka%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">mingyouxiaozhu</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
